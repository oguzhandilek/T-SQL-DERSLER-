T-SQL DERSLERÄ°

ServerName alanÄ± iÃ§in "." localhost ve (local) yazmanÄ±z aynÄ± ÅŸeyler ifade eder.

localhostta yenii bir veritabanÄ± oluÅŸurmak iÃ§in CMD  satÄ±rÄ±na localdb create veritabaniAdi yazmanÄ±z yeterli.
 Daha sonra Managment Sever Name alanÄ±na (local)\veritabaniAdi yazarak baÄŸlanabilirisniz.
 
 
 
 
 
 --SELECT KOMUTU
select 3

select 3,5,7

select 'OÄŸuzhan'

print 'Dilek'

select * from Northwind.dbo.Personeller

select Adi, SoyAdi from Northwind.dbo.Personeller

--  ALIAS ATAMA
Select Adi AdÄ±, SoyAdi Soyisimler from Northwind.dbo.Personeller

-- BoÅŸluk Karakteri Olan Alias atama

select 1453 [Ä°stanbulun Fethi]


-- BoÅŸluk Karakteri Olan Tablo Sorgulama

select * from Northwind.dbo.[Satis Detaylari]

-- KolonlarÄ± BirleÅŸtirme

Select Adi+' '+ SoyAdi [Ä°sim  ve Soyisimler]  from Northwind.dbo.Personeller

-- FarklÄ± Tipte kolon BirleÅŸtirme

Select Adi+' '+ CONVERT(nvarchar,IseBaslamaTarihi) [Ä°ÅŸe BaÅŸlama Tarihleri] from Northwind.dbo.Personeller

Select Adi+' '+ CAST(IseBaslamaTarihi as nvarchar) [Ä°ÅŸe BaÅŸlangÄ±Ã§]  from Northwind.dbo.Personeller







USE Northwind

-- SELECT SORGULARÄ±NDA (WHERE) ÅARTÄ± YAZMAK

select * from dbo.Personeller

select * from dbo.Personeller where Sehir='London'

select * from dbo.Personeller where BagliCalistigiKisi<5

--And OperatÃ¶rÃ¼
-- Personeller tablosunda ÅŸehri london ve Ã¼lkesi UK olanlarÄ± listeleyelim.

select * from dbo.Personeller where Sehir='London' and Ulke='UK'

-- Or OperatÃ¶rÃ¼
-- Personeller tablosunda UnvanEki 'MC.' olan veya ÅŸehri Seattle olan tÃ¼m personelleri listeleyelim.

select * from dbo.Personeller where UnvanEki='Mr.' or  Sehir='Seattle'

--KarÅŸÄ±k Ã–rnekler
--AdÄ± Robert soyadÄ± King olan personelin tÃ¼m bilgilerini Ã§ek.

select * from dbo.Personeller where Adi='Robert' and SoyAdi='King'

-- PersonellD'si 5 olan personeli getir.
select * from dbo.Personeller where PersonelID=5

-- PersonellD'si 5 'ten bÃ¼yÃ¼k olan tÃ¼m personelleri getir.

select * from dbo.Personeller where PersonelID>=5

-- <> EÅŸit DeÄŸilse
-- = EÅŸitse
-- <= KÃ¼Ã§Ã¼k ve EÅŸitse
-- >= BÃ¼yÃ¼k ve EÅŸitse

-- Fonksiyon SonuÃ§larÄ±nÄ± ÅŸart Olarak Kullanmak
--- 1993 yÄ±lÄ±nda Ä°ÅŸe baÅŸlayanlarÄ± listele.

select * from dbo.Personeller where year(IseBaslamaTarihi)=1993

--- 1992 yÄ±lÄ±ndan sonra iÅŸe baÅŸlayanlarÄ± listele.

select * from dbo.Personeller where YEAR(IseBaslamaTarihi)>1992

-- DoÄŸum gÃ¼nÃ¼, ayÄ±n 29 olan personelleri listeleyelim.

select *from dbo.Personeller where Day(DogumTarihi)=29

--DoÄŸum yÄ±lÄ± 1950 ile 1965 yÄ±llarÄ± arasÄ±nda olan personelleri getirelim.

select * from dbo.Personeller where YEAR(DogumTarihi)>1950 and YEAR(DogumTarihi)<1965

--- YaÅŸadÄ±ÄŸÄ± ÅŸehrin Lcndon, Taccma ve Kirkland olan personellerin adÄ±nÄ± listeleyelim.

select Adi AdÄ± from dbo.Personeller where Sehir='London' or Sehir='Kirkland' or sehir='Tacoma'

---Between Komutu
select * from dbo.Personeller where YEAR(DogumTarihi)>1950 and YEAR(DogumTarihi)<1965

select * from dbo.Personeller where YEAR(DogumTarihi) between 1950 and 1965

select * from dbo.Personeller where PersonelID between 2 and 5

--In Komutu

 select Adi Ä°simler from dbo.Personeller where Sehir='London' or Sehir='Tacoma' or Sehir='Kirkland'

 select Adi isimler from dbo.Personeller where Sehir in('London','Tacoma','Kirklanda')

 select Adi AdÄ±, DogumTarihi [DoÄŸum Tarihi] from  dbo.Personeller where YEAR(DogumTarihi) in(1948,1963)
 
 
 
 
 
 
 
 Use Northwind
 -- LIKE SORGULARÄ±
-- % (Genel Ã–nemli DeÄŸil) OperatÃ¶rÃ¼

-- Ä°sminin baÅŸ harfi j olan personellerin adÄ±nÄ± ve soyadÄ±nÄ± yazdÄ±ralÄ±m.

select Adi AdÄ±, Soyadi SoyadÄ±  from dbo.Personeller where Adi like('j%')

-- Ä°sminin son harfi y olan personellerin adÄ±nÄ± ve soyadÄ±nÄ± yazdÄ±ralÄ±m.

select Adi Ä°sim, SoyAdi Soyisim from dbo.Personeller where Adi like '%y'

--- Ä°sminin son Ã¼Ã§ harfi ert olan personeli getirelim.

select Adi,Soyadi from dbo.Personeller where Adi like '%ert'

--- Ä°sminin ilk harfi r, son harfi t olan personeli getirelim.

select Adi,Soyadi from dbo.Personeller where Adi like 'r%t'

-- Gereksiz bir kullanÄ±m.
select Adi,Soyadi from dbo.Personeller where Adi like 'r%' and Adi like'%t'

--- Ä°sminde an geÃ§en personelin adÄ±nÄ± yazdÄ±ralÄ±m.

select Adi,Soyadi from dbo.Personeller where Adi like '%an%'

--- Ä°sminin baÅŸ harfi n olan ve Ä°Ã§erisinde an geÃ§en personeli getirelim.

select Adi,Soyadi from dbo.Personeller where Adi like 'n%an%'

-- Gereksiz bir kullanÄ±m.

select Adi,Soyadi from dbo.Personeller where Adi like 'n%' and Adi like'%an%'



-- _(Ã¶zel Onemli DeÄŸil) OperatÃ¶rÃ¼

-- Ä°sminin ilk harfi a, ikinci harfi fark etmez ve Ã¼Ã§Ã¼ncÃ¼ harfi d olan personeli getirelim.

select * from dbo.Personeller where Adi like 'a_d%'

-- Ä°sminin ilk harfi m, ikinci -Ã¼Ã§Ã¼ncÃ¼ - dÃ¶rdÃ¼ncÃ¼ fark etmez ve beÅŸinci harfi a olan personeli getirelim.

select * from dbo.Personeller where Adi like 'm___a%'

--[](ya da) OperatÃ¶rÃ¼

-- Ä°sminin ilk harfi n ya da m ya da r olan personelleri getirelim.

select * from dbo.Personeller where Adi like '[nmr]%'

-- Ä°sminin Ä°Ã§erisinde a ya da Ä° geÃ§en personelleri getirelim.

select * from dbo.Personeller where Adi like '%[ai]%'

-- [*-*] (Alfabetik ArasÄ±nda) OperatÃ¶rÃ¼

--- Ä°sminin baÅŸ harfi a Ä°le k arasÄ±nda alfabetik sÄ±raya gÃ¶re herhangi bir harf olan personellerin adÄ±nÄ± yazdÄ±ralÄ±m.

select * from dbo.Personeller where Adi like '[a-k]%'


-- [^*] (DeÄŸil) OperatÃ¶rÃ¼

--- Ä°sminin baÅŸ harfi a olmayan personelleri getirelim.

select *from dbo.Personeller where Adi like '[^a]%'

--- Ä°sminin baÅŸ harfi a ya da n olmayan personelleri getirelim.

select * from dbo.Personeller where Adi like '[^an]%'

-- Escape(KaÃ§Ä±ÅŸ) Karakterleri
-- Like sorgularÄ±nda kullandÄ±ÄŸÄ±mÄ±z %, _ , [] gibi Ã¶zel ifadeler eÄŸer ki verilerimiz iÃ§erisinde geÃ§iyorsa sorgulama esnasÄ±nda hata Ä°le karÅŸÄ±laÅŸabiliriz. BÃ¶yle durumlarda bu ifadelerin Ã¶zel ifade olmadÄ±ÄŸÄ±nÄ± escape karakterleri Ä°le belirleyebiliriz.
-- [] OperatÃ¶rÃ¼ Ä°le
-- Escape Komutu Ä°le

 select * from dbo.Personeller where Adi like '[_]%'

 select  Adi,Soyadi from dbo.Personeller where SoyAdi like 'n%%' escape 'n'
 
 select  Adi,Soyadi from dbo.Personeller where SoyAdi like 'n%%' escape 'n' --n kaÃ§Ä±ÅŸÄ±n baÅŸlangÄ±Ã§ alias gibi dÃ¼ÅŸÃ¼nebiliriz n den bir sonraki keyword deÄŸil demek 
 
 
 
 
 
 --AGGREGATE FONKSÄ°YONLAR

-- AVG : Ortlama AlÄ±r

select AVG(PersonelID) PersonelIdOrtalamasi from .dbo.Personeller

select AVG(BirimFiyati) [Birim FiyatÄ± Ort] from dbo.[Satis Detaylari]

--MAX: En BÃ¼yÃ¼k DeÄŸeri Bulur

select max(miktar) Miktar from dbo.[Satis Detaylari]

--MIN : En KÃ¼Ã§Ã¼k DeÄŸeri Bulur

select min(miktar) Miktar from dbo.[Satis Detaylari]

-- COUNT: Toplam kayÄ±t SaysÄ±nÄ± Verir

select COUNT(*) from dbo.Personeller

select count(Adi) [KayÄ±t SayÄ±sÄ±] from dbo.Personeller

-- SUM: ToplamÄ±nÄ± Verir

select sum(nakliyeUcreti) nakliyeUcreti from dbo.[Satislar]







--STRING FONKSÄ°YONLAR

-- LEFT :Soldan(baÅŸtan) belirtilen sayÄ±da karakteri getirir.
Select Adi, LEFT(Adi,2) from dbo.Personeller

-- RÄ°GHT : SaÄŸdan(sondan) belirtilen sayÄ±da karakteri getirir.

select Adi, RIGHT(Adi,2) from dbo.Personeller

-- UPPER :BÃ¼yÃ¼k harfe Ã§evirir.

select UPPER(Adi) from dbo.Personeller

select left(UPPER(Adi),3) from dbo.Personeller

-- UPPER :BÃ¼yÃ¼k harfe Ã§evirir.

select UPPER(SoyAdi) from dbo.Personeller

-- SUBSTRING : Belirtilen indexten itibaren belirtilen sayÄ±da karakter getir.

select soyadi, SUBSTRING(SoyAdi,2,3) from dbo.Personeller

-- LTRIM :Soldan boÅŸluklarÄ± keser.

select '       OÄŸuzhan'
select LTRIM('     OÄŸuzhan')

--- RTRIM : SaÄŸdaki boÅŸluklarÄ± keser.

select RTRIM('Zehra     ')

--- REVERSE :Tersine Ã§evirir.

select REVERSE(Adi) from dbo.Personeller

--- REPLACE :Belirtilen ifadeyi, belirtilen ifade ile deÄŸiÅŸtirir.

select REPLACE('Merhaba ben OÄŸuzhan','OÄŸuzhan','Zehra') 

--CHARINDEX :Belirtilen karakterin veri iÃ§inde sÄ±ra numarasÄ±nÄ± verir.

select MusteriAdi, CHARINDEX('r',MusteriAdi) from dbo.Musteriler

-- CHARINDEX ornek
--- MÃ¼ÅŸteriler tablosunun MusteriAdi kolonundan sadece adlarÄ±nÄ± Ã§ekelim.

select MusteriAdi, SUBSTRING(MusteriAdi,0,CHARINDEX(' ',MusteriAdi)) [Ä°lk AdÄ±] from dbo.Musteriler

--- MÃ¼ÅŸteriler- tablosunun Musterâ€¢iAdi kolonundan sadece soyadlarÄ±nÄ± Ã§ekelim.

select MusteriAdi
,SUBSTRING(MusteriAdi
,CHARINDEX(' ',MusteriAdi)
,LEN(MusteriAdi)-(charindex(' ',MusteriAdi)-1)) 
from dbo.Musteriler





-- SAYÄ±SAL DEÄER Ä°ÅLEMLERI

select 3 + 2
select 4-2
select 5*2 
select 10/2

--Pi sayÄ±sÄ±nÄ± verir.
select PI()

--- SIN : SinÃ¼s alÄ±r.
select SIN(90)

-- POWER :Ãœs alÄ±r.
select power(2,3)

-- ABS : Mutlak deÄŸer alÄ±r.
select abs(-12)

--RAND: 0 - 1 arasÄ±nda rastgele sayÄ± Ã¼retir.
Select RAND()

-- FLOOR :Yuvarlama yapar.
select FLOOR(rand()*100)



-- Tarih FonksiyonlarÄ±
--- GETDATE :Bu gÃ¼nÃ¼n tarihini verir.

select GETDATE()

-- DATEADD :Verilen tarihe verildiÄŸi kadar gÃ¼n, ay, yÄ±l ekler.

select DATEADD(day,999,getdate())

select DATEADD(month,99,getdate())

select DATEADD(year,9,'5.5.2009')

-- DATEDIFF : Ä°ki tarih arasÄ±nda gÃ¼nÃ¼, ayÄ± veya yÄ±lÄ± hesaplar.

select DATEDIFF(day,'01.01.2025',getdate())
select DATEDIFF(day,'06.29.2015',getdate())

select DATEDIFF(month,'08.14.2021',getdate())

select DATEDIFF(year,'02.02.2024',GETDATE())

--- DATEPART :Verilen tarihin haftanÄ±n, ayÄ±n yahut yÄ±lÄ±n kaÃ§Ä±ncÄ± gÃ¼nÃ¼ olduÄŸunu hesaplar.

select DATEPART(DW,GETDATE()) --DW: Weekday

select DATEPART(month,getdate())

select DATEPART(day,getdate())

select DATEPART(year,getdate())




Use Northwind

--Top Komutu

select TOP 5 * from Personeller


--Distinct Komutu

select Sehir from Personeller

select DISTINCT Sehir from Personeller


--Group By Komutu

--Formulize edecek olursak: Normal kolon yanÄ±nda Aggregate fonksiyon Ã§aÄŸrÄ±lÄ±yorsa normal kolon Group By ile gruplanÄ±r

select PersonelID, count(*) [YaptÄ±ÄŸÄ± SatÄ±ÅŸ] from Satislar  GROUP BY PersonelID

select KategoriID,count(*) from Urunler group by KategoriID

select KategoriID,TedarikciID, count(*) from Urunler group by KategoriID,TedarikciID  --Birden fazla kolonu gruplama Ã¶rneÄŸi

select * from Urunler

select * from Satislar

select PersonelID,SUM(NakliyeUcreti) [Toplam Nakilye Ucreti] from Satislar group by PersonelID

--- Group By iÅŸleminde Where ÅartÄ± Kullanma

select PersonelID, count(*) from Satislar where PersonelID>5 group by PersonelID

select * from Urunler

select UrunAdi, BirimFiyati, count(*) [50 TL ve Uzeri] from Urunler where BirimFiyati>=50 group by UrunAdi,BirimFiyati

---Group By Ä°ÅŸleminde Having Komutu Kullanarak ÅŸart oluÅŸturma
--Not: Where komutu ile arasÄ±ndaki fark: Having aggregate fonksiyon iÃ§in ÅŸart gerekirse yazÄ±lÄ±r ve groupby komutundan sonra gelir.

select PersonelID, count(*) [Toplam KayÄ±t] from Satislar where PersonelID>5 group by PersonelID having count(*)>70




-- TablolarÄ± Yan Yana BirleÅŸtitme

Select * from Personeller
select * from Satislar

select * from Personeller, Satislar

select p.PersonelID, s.MusteriID from Personeller p , Satislar s

select p.PersonelID,s.PersonelID, count(*) [Toplam KayÄ±t] from Personeller p,Satislar s where p.PersonelID=s.PersonelID group by p.PersonelID,s.PersonelID

--YukarÄ±daki birleÅŸtirme Ã¶rneÄŸi ilkel bir yapÄ±dadÄ±r. aÅŸaÄŸÄ±da Joinleri bu yapÄ±yÄ± baz alarak iÅŸleyip  avantajlarÄ± veya dezavantajlarÄ±nÄ± inceleyeceÄŸiz




--- Inner Join veya Join
--- Genel MantÄ±k
--- Select * from Tablo1 Inner Join Tab1o2 on Tablo1.IliskiliKolon=Tablo2.IliskiliKolon
--- Tablolara alias tanÄ±mlanabilir.
--- Select * from Tablo1 t1 Inner Join Tablo2 t2 on t1.IliskiliKolon=t2.IliskiilKolon
--- Ä°ki Tabloyu Ä°liÅŸkisel BirleÅŸtirme
USE Northwind

--- Hangi personel hangi satÄ±ÅŸlarÄ± yapmÄ±ÅŸtÄ±r.(Personeller,Satislar)

select * from Personeller
select * from Satislar

select p.Adi+' '+p.SoyAdi [AdÄ± SoyadÄ±], s.SevkAdi from Personeller p inner join Satislar s on p.PersonelID=s.PersonelID 

--Hangi Ã¼rÃ¼n hangi kategoride. (Urunler, Kategoriler)

select u.UrunAdi, k.KategoriAdi from Urunler u inner join Kategoriler k on u.UrunID=k.KategoriID


--Inner Join'de Where Komutunun KullanÄ±mÄ±

--Beverages kategorisindeki Ã¼rÃ¼nlerim. (Urunler, Kategoriler)

select * from Urunler u inner join Kategoriler k on u.UrunID=k.KategoriID where k.KategoriAdi='Beverages'

--Beverages kategorisindeki Ã¼rÃ¼nlerimin sayÄ±sÄ± kaÃ§tÄ±r. (Urunler, Kategoriler)

select count(u.UrunAdi) KayÄ±t from Urunler u inner join Kategoriler k on u.UrunID=k.KategoriID where k.KategoriAdi='Beverages'

--Seafood kategorisindeki Ã¼rÃ¼nlerin listesi (Urunler, Kategoriler)

select u.UrunAdi Urunler from Urunler u inner join Kategoriler k on u.UrunID=u.KategoriID where k.KategoriAdi='Seafood'

--Hangi satÄ±ÅŸÄ± hangi Ã§alÄ±ÅŸanÄ±m yapmÄ±ÅŸ? (Satislar, Personeller)

select p.Adi+' '+p.SoyAdi [AdÄ± SoyadÄ±], s.SevkAdi from Satislar s inner join Personeller p  on s.PersonelID=p.PersonelID 

--Faks numarasÄ± 'nullâ€ olmayan tedarikcilerden alÄ±nmÄ±ÅŸ Ã¼rÃ¼nler nelerdir? (Urunler,Tedarikciler)

select u.UrunAdi,t.Faks from Urunler u inner join Tedarikciler t on u.TedarikciID=t.TedarikciID where t.Faks<>'Null'

select u.UrunAdi,t.Faks from Urunler u inner join Tedarikciler t on u.TedarikciID=t.TedarikciID where t.Faks is not null




-- - Ä°kiden Fazla Tabloyu Ä°liÅŸkisel BirleÅŸtirme
--- 1997 yÄ±lÄ±ndan sonra Nancy nin satÄ±ÅŸ yaptÄ±ÄŸÄ± firmalarÄ±n isimleri: (1997 dahil)(MÃ¼ÅŸteriler, Satislar, Personeller)

select p.Adi, m.SirketAdi from Personeller p inner join Satislar s on p.PersonelID=s.PersonelID inner join Musteriler m on m.MusteriID=s.MusteriID where p.Adi='Nancy' and  Year(s.SatisTarihi)>=1997

-- Limited olan tedarikÃ§ilerden alÄ±nmÄ±ÅŸ seafood kategorisindeki Ã¼rÃ¼nlerimin toplam satÄ±ÅŸ tutarÄ±. (Urunler , Kategoriler, Tedarikciler)

select Sum(u.BirimFiyati * u.HedefStokDuzeyi) [Toplam SatÄ±ÅŸ TutarÄ±] from Kategoriler k inner join Urunler u on k.KategoriID=u.KategoriID inner join Tedarikciler t on t.TedarikciID=u.TedarikciID where k.KategoriAdi='Seafood' and t.SirketAdi Like '%Ltd.%'



-- - AynÄ± Tabloyu Ä°liÅŸkisel Olarak BirleÅŸtirme

-- Personellerimin baÄŸlÄ± olarak Ã§alÄ±ÅŸtÄ±ÄŸÄ± kiÅŸileri listele? (Personeller, Personeller)

select ast.Adi Ast, ust.Adi Ust from Personeller ust inner join Personeller ast on ust.PersonelID=ast.BagliCalistigiKisi


-- Inner Joinde Grup By

use Northwind
-- Hangi personelim(adl ve soyadÄ± Ä°le birlikte), toplam kaÃ§ adetlik satÄ±ÅŸ yapmÄ±ÅŸ. SatÄ±ÅŸ adedi 100 den fazla olanlar ve personelin adÄ±nÄ±n baÅŸ harfi M olan kayÄ±tlar gelsin. (Personeller, Satislar)

select p.Adi+' '+p.SoyAdi [AdÄ±SoyadÄ±], count(s.SatisID) from Personeller p inner join Satislar s on p.PersonelID=s.PersonelID  where p.Adi like 'M%' group by p.Adi+' '+p.SoyAdi having COUNT(s.SatisID)>100 

--- Seafood kategorisindeki Ã¼rÃ¼nlerin sayÄ±sÄ±? (Urunler, Kategoriler)

select k.KategoriAdi, count(*) KayitSayisi from Kategoriler k inner join Urunler u on k.KategoriID=u.KategoriID where k.KategoriAdi='Seafood' group by k.KategoriAdi

-- Hangi personelim toplam kaÃ§ adet satÄ±ÅŸ yapmÄ±ÅŸ? (Personeller, Sati51ar)

select p.Adi+' '+p.SoyAdi [AdÄ± SoyadÄ±], count(*) [SattÄ±ÄŸÄ± Urun Adeti] from Personeller p inner join Satislar s on p.PersonelID=s.PersonelID group by p.Adi+' '+p.SoyAdi

--- En Ã§ok satÄ±ÅŸ yapan personelim? (Personeller, Satislar)
select top 1 p.Adi, COUNT(*) from Personeller p inner join Satislar s on p.PersonelID=s.PersonelID group by p.Adi order by COUNT(*) desc

--- AdÄ±nda "aâ€ harfi olan personellerin satÄ±ÅŸ id si 10500 den bÃ¼yÃ¼k olan satÄ±ÅŸlarÄ±nÄ±n toplam tutarÄ±nÄ±(miktar*birimfiyat) ve bu satÄ±ÅŸlarÄ±n hangi tarihte gerÃ§ekleÅŸtiÄŸini listele. (Personeller, Satislar, [SatÄ°s Detaylari)

 select convert(nvarchar,day(s.SatisTarihi)) + '.' + convert(nvarchar,month(s.Satistarihi)) + '.' + convert(nvarchar,year(s.Satistarihi)) [SatÄ±ÅŸ Tarihi], SUM(d.Miktar*d.BirimFiyati) [toplam SatÄ±ÅŸ TutarÄ±] from Personeller p inner join Satislar s on p.PersonelID=s.PersonelID inner join [Satis Detaylari] d on s.SatisID=d.SatisID where p.Adi like '%a%' and s.SatisID>10500 group by s.SatisTarihi order by s.SatisTarihi asc




--Outer Join(Left,Right,Full) ile TablolarÄ± BirleÅŸtirme 

use OrnekVT
INSERT INTO Filmler (Filmid, FilmAdi) VALUES
(1, 'GORA'),
(2, 'Lord Of The Rings'),
(3, 'DÃ¼ÄŸÃ¼n Dernek'),
(4, 'Bir Zamanlar Anadolu''da'),
(5, 'Kurtlar Vadisi'),
(6, 'Recep Ä°vedik'),
(7, 'DÃ¼ÄŸÃ¼n Dernek'),
(8, 'Kahpe Bizans');

select * from Filmler

INSERT INTO Oyuncular (OyuncuId, Filmid, Adi, Soyadi) VALUES
(1, 1, 'Cem', 'YÄ±lmaz'),
(2, 2, 'Muiddin', 'Ä°mpatrino'),
(4, 2, 'Turgay', 'Arslaner'),
(5, 3, 'GÃ¶khan', 'AÅŸker'),
(6, 4, 'Mustafa', 'AÄŸaoÄŸlu'),
(7, 4, 'Mustafa', 'GÃ¼loÄŸlu'),
(8, 5, 'Mustafa', 'NuroÄŸlu'),
(9, 5, 'M ust4', 'BilmemneoÄŸlu');

select * from Oyuncular


-- Inner Jcin'de eÅŸleÅŸen kayÄ±tlar getiriliyordu. Outer Join 'de ise eÅŸleÅŸmeyen kayÄ±tlarda getirilmektedir.


-- Left Join
-- Join ifadesinin solundaki tablodan tÃ¼m kayÄ±tlarÄ± getirir. SaÄŸÄ±ndaki tablodan eÅŸleÅŸenleri yan yana eÅŸleÅŸmeyenleri null olarak getirir.

select * from Filmler f left outer join Oyuncular o on f.FilmId=o.FilmID
select * from Oyuncular o left outer join Filmler f on o.FilmID=f.FilmId

-- veya

select * from Oyuncular o left join Filmler f on o.FilmID=f.FilmId
select *from Filmler f left join Oyuncular o on f.FilmId=o.FilmID

--Not : outer keyword'Ã¼ eskiden kullanÄ±lÄ±yordu. GÃ¼ncel olarak kullanÄ±lmasÄ±na gerek yok dolayÄ±syla aÅŸaÄŸÄ±daki komutlarda outer keyword'Ã¼ yazÄ±lmayacak.

--- Right Join
-- Joinin saÄŸÄ±ndaki tablonun tamamÄ±nÄ± getirecek, solundakinden eÅŸleÅŸenleri aynÄ± satÄ±rda eÅŸleÅŸmeyenleri de null olarak getirecek.

select * from Oyuncular o right join Filmler f on o.FilmID=f.FilmId
select* from Filmler f right join  Oyuncular o on o.FilmID=f.FilmId


-- Full Join
--- Joinin iki tarafÄ±ndaki tablolardan eÅŸleÅŸen eÅŸleÅŸmeyen hepsini getirir.
select * from Oyuncular o full join Filmler f on o.FilmID=f.FilmId

select * from Filmler f full join Oyuncular o on o.FilmID=f.FilmId





--Cross Join 
-- Cross Join iki tablo arasÄ±nda kartezyen Ã§arpÄ±m saÄŸlar ve sonucu tablo olarqak dÃ¶ndÃ¼rÃ¼r.
--AÅŸaÄŸÄ±daki Ã¶rnekte iki farklÄ± tabloyu cross join ile birleÅŸtireceÄŸiz. DoÄŸru birleÅŸmenin saÄŸlamasÄ±nÄ± iki tablonun eleman saysÄ±nÄ±n Ã§arpÄ±mÄ± ile doÄŸrulancakatÄ±r. Ã–rnek: Personeller Count = 9 BÃ¶lge Count =4 9*4=36 adet sonuÃ§ dÃ¶ndÃ¼rmesi gerekiyor.
use Northwind
select count(*) from Personeller 
select count(*) from Bolge

select p.Adi,b.BolgeID from Personeller p cross join Bolge b

--Not:
--1) DiÄŸer Join komutlarÄ±nda olduÄŸu gibi ON keyword'Ã¼nÃ¼ kullanmayÄ±z. Ã‡Ã¼nkÃ¼ kartezyen Ã§arpÄ±m ile bÃ¼tÃ¼n eÅŸleÅŸmeleri yapÄ±yor.
--2) Where keyword2Ã¼ ile herhangi bir ÅŸartta baÄŸlanamaz.

--Ã–rnek :
--10 Ã¶ÄŸrenci adayÄ± var âœ…

--9 farklÄ± temin tipi var âœ…

--Her Ã¶ÄŸrenci adayÄ± her temin tipini seÃ§ebilir (tÃ¼m kombinasyonlar gerekir) âœ…

--Yani:

--Her Ã¶ÄŸrenci 9 temin tipinden birini seÃ§ebileceÄŸi gibi hepsiyle eÅŸleÅŸmesi de ihtimal dahilinde.
--SonuÃ§: 10 Ã— 9 = 90 satÄ±r




-----DML KOMUTLARINA GÄ°RÄ°Å----

--DML (Data Manipulation Language)
---- Select, insert, Update, Delete
--- Select...
--- insert ...
--- Update ...
--- Delete ...

USE Northwind

--Select 
Select * from Personeller


--Insert 
-- Insert [Tablo AdÄ±] (Kolonlar) Values(DeÄŸerler)

--Kolon adÄ± belirterek ekleme
insert  Personeller(Adi,SoyAdi) values('OÄŸuzhan','Dilek') --Kolon adlarÄ± ile gÃ¶ndereceÄŸiniz values'ler aynÄ± Ä±rada olamalÄ±dÄ±r.

--TÃ¼m Kolonlara veri ekleme

insert Personeller values('Dilek','Zehra','TatlÄ± Bebek','Immm','01.01.2024',GETDATE(),'Ankara','Erzurum','Ä°Ã§Anadolu','0600','Turkiye',null,null,null,null,null,null)


--- [Dikkat Edilmesi Gerekenler! ! ! ]
--- Into Komutu Ä°le YazÄ±labilir
insert into Personeller(SoyAdi,Adi) values('Dilek','SutlaÃ§')
--- Kolonun kabul ettiÄŸi veri tipi ve karakter uzunluÄŸunda kayÄ±t yapÄ±lmalÄ±dÄ±r.
--- Not NuII olan kolonlara boÅŸ bÄ±rakÄ±lamayacaklarÄ±ndan dolayÄ± mutlaka deÄŸer gÃ¶nderilmelidir.
insert Personeller(Unvan,UnvanEki) values ('Doktor','Prof.')

-- Otomatik artan(Ä°dentÄ°ty) kolonlara deÄŸer gÃ¶nderilmez.
-- Tablodaki seÃ§ilen yahut bÃ¼tÃ¼n kolonlara deÄŸer gÃ¶nderileceÄŸi belirtilip, gÃ¶nderilmezse hata verecektir.

insert Personeller(Adi,SoyAdi) values('Dilek')
insert Personeller values('Dilek')

---[Pratik KullanÄ±m]
insert Personeller(Adi,Soyadi) values ('Sulhettin','Kebap')
insert Personeller(Adi,Soyadi) values ('Murtaza','Yanbakan')
insert Personeller(Adi,Soyadi) values ('MugÄ±me','DÃ¼zayak')

insert Personeller(Adi,SoyAdi) values ('Sulhettin','Kebap'),
	('Murtaza','Yanbakan'),
	('MugÄ±me','DÃ¼zayak')
	
	
	
--- [insert Komutu Ä°le Select Sorgusu Sonucu Gelen Verileri FarklÄ± Tabloya Kaydetme]
select * from OrnekPersoneller
insert OrnekPersoneller select Adi,Soyadi from Personeller
-- Burada dikkat etmeniz gereken nokta; Select sorgusunda donen kolon sayÄ±sÄ± Ä°le insert Ä°ÅŸlemi yapÄ±lacak tablonun;
-- 1) kolon sayÄ±sÄ± birbirine eÅŸit olmasÄ± 
-- 2) tiplerinin aynÄ± olmasÄ±
-- 3) Kolon SÄ±rasÄ±nÄ±n aynÄ± olmasÄ± gerekmektedir.
-- 4) Kolon isimlerinin dahi aynÄ± olamsÄ± lazÄ±m


-- [Select Sorgusu Sonucu Gelen Verileri FarklÄ± Bir Tablo OluÅŸturarak Kaydetme]
 select Adi,Soyadi,Ulke into OrnekPersoneller2 from Personeller
 select * from OrnekPersoneller2
--- Bu yÃ¶ntemle primary key ve foreign keyler oluÅŸturulamazlar.



--- Update
--- Update [Tablo AdÄ±] Set [Kolon AdÄ±] = DeÄŸer

use Northwind

update OrnekPersoneller set Adi='ÃœlkÃ¼' where Adi='Zehra' --EÄŸer where ÅŸartÄ± konulmazsa bÃ¼tÃ¼n kolunun hepsini set edilen deÄŸer ile gÃ¼nceller
select * from OrnekPersoneller

--- [Update Sorgusunda Join YapÄ±larÄ±nÄ± Kullanarak Birden Fazla Tabloda GÃ¼ncelleme Yapmak]
select * from OrnekPersoneller
--Personeller tablsounda 12 ID'li personelin soyadÄ±nÄ±  OrnekPersoneller tablsonudaki AdÄ± kolnuyla gÃ¼ncelle
update OrnekPersoneller set Adi= p.SoyAdi from Personeller p inner join OrnekPersoneller o on p.PersonelID=o.PersonelId where p.PersonelID=12

--- [Update Sorgusunda Subquery Ä°le GÃ¼ncelleme Yapmak)

Update OrnekPersoneller set Soyadi=(Select Adi from Personeller where PersonelID=3) where OrnekPersoneller.Adi='Janet'

--- [Update Sorgusunda Top KeywordÃ¼ Ä°le GÃ¼ncelleme Yapmak]

update top (3) OrnekPersoneller set SoyAdi=null


--- Delete
--- Delete from [Tablo AdÄ± ]

--[Delete Sorgusuna Where Åartl Yazmak]


Delete From OrnekPersoneller where PersonelId<=3
select * from OrnekPersoneller
--- [Dikkat Edilmesi Gerekenler! ! ! ]
-- Delete sorgusuyla tablo iÃ§erisindeki tÃ¼m verileri silmeniz identity kolonunu sÄ±frlamayacaktÄ±r. Silme iÅŸleminden sonra Ä°lk eklenen veride kalÄ±ndÄ±ÄŸÄ± yerden id deÄŸeri verilecektir.
delete from OrnekPersoneller where Adi in ('Zehra')



-- Union | UnÄ°on All
--- Union Komutu
--- Birden fazla select sorgusu sonucunu tek seferde alt alta gÃ¶stermemizi saÄŸlar.

---AiaÅŸÄ±daki senaryoda Musteriler tablosundaki ad soyadlarÄ± alÄ±p SÄ±nÄ±fA , Personeller Tablosundaki  ad soyadlarÄ± alÄ±p SÄ±nÄ±fB TablolarÄ± oluÅŸturlacak ve bunlarÄ± Union ile birleÅŸtirip alt alat sÄ±ralama yapacaÄŸÄ±z. bu ÅŸeilde Okuladki tÃ¼m Ã¶ÄŸrenci listesi Ã§Ä±kmÄ±ÅŸ olacak

select SUBSTRING(MusteriAdi,0,CHARINDEX(' ',MusteriAdi)) [Adi],SUBSTRING(MusteriAdi,CHARINDEX(' ',MusteriAdi),LEN(MusteriAdi)-(charindex(' ',MusteriAdi)-1))[SoyAdi]  into SinifB from Musteriler

select PersonelID,SoyAdi,Adi into SinifA from Personeller


Select  Adi,SoyAdi from SinifA
Union
Select Adi,SoyAdi from SinifB

--- 2 'den fazla
Select  Adi,SoyAdi from SinifA
Union
Select Adi,SoyAdi from SinifB
Union
Select Adi,SoyAdi from Personeller

--Joinler yan yana, Union alt alta tablolarÄ± birleÅŸtirir. Joinlerde belirli(iliÅŸkisel) bir kolon Ã¼zerinden birleÅŸtirme yapÄ±lÄ±rken, Union 'da bÃ¶yle bir durum yoktur.

--- Dikkat etmemiz gereken koÅŸullar;
-- Union sorgusunun sonucunda oluÅŸan tablonun kolon isimleri, Ã¼stteki sorgunun kolon Ä°simlerinden oluÅŸturulur.
--- Ãœstteki sorgudan kaÃ§ kolon Ã§ekilmiÅŸse alttaki sorgudan da o kadar Ã§ekilmek zorundadÄ±r.
-- Ãœstteki sorgudan Ã§ekilen kolonlarÄ±n tipleriyle, alttaki sorgudan Ã§ekilen kolonlarÄ±n tipleri uyumlu olmalÄ±dÄ±r.
--- Union tekrarlÄ± kayÄ±tlarÄ± getirmez.
-- Union'da kullanÄ±lan tablolara kolon eklenebilir. Dikkat etmemiz gereken nokta, yukarÄ±daki kurallar Ã§erÃ§evesinde aÅŸaÄŸÄ±yada yukarÄ±yada aynÄ± sayÄ±da kolonlarÄ±n eklenmesi gerekmektedir.


Select  Adi,SoyAdi,'A SÄ±nÄ±fÄ±' from SinifA
Union
Select Adi,SoyAdi,'B SÄ±nÄ±fÄ±' from SinifB

-- Union ALL
--- Union tekrarlÄ± kayÄ±tlarÄ± getirmez. TekrarlÄ± kayÄ±tlarÄ± getirmek iÃ§in Union All Komutu kullanÄ±lmalÄ±dÄ±r.

Select  Adi,SoyAdi from SinifA
Union All
Select Adi,SoyAdi from SinifA




-- With Rollup | Wtith Cube

-- With Rollup Group By ile gruplanmÄ±ÅŸ veri kÃ¼mesinde ara toplam alÄ±nmasÄ±nÄ± saÄŸlar.

Select Sehir,Urun,Sum(SatisMiktari) from Satislar group by Sehir,Urun with rollup
 --Sadece ÅŸehir bazlÄ± toplamlar + genel toplam var.

 --- [Having ÅartÄ±yla Beraber With Rollup]
 Select Sehir,Urun,Sum(SatisMiktari) from Satislar group by Sehir,Urun with rollup having sum(SatisMiktari)>10
 
 
 --With Cube TÃ¼m gruplarÄ±n tÃ¼m olasÄ± kombinasyonlarÄ±nÄ±n toplamlarÄ±nÄ± verir.

 Select Sehir,Urun,Sum(SatisMiktari) from Satislar group by Sehir,Urun with cube
 --ğŸ‘‰ Hem ÅŸehir hem Ã¼rÃ¼n bazlÄ± toplamlar + genel toplam var.

  --- [Having ÅartÄ±yla Beraber With Cube]
 Select Sehir,Urun,Sum(SatisMiktari) from Satislar group by Sehir,Urun with cube having sum(SatisMiktari)>10



-- Case - When- Else â€” End
-- Personellerimizin isim ve soyisimlerinin yanÄ±nda; UnvanEki 'Mr'Ä°se  Erkek, 'Ms.' ve'Mrs.' ise KadÄ±n  yazsÄ±n.

select Adi,SoyAdi,
Case
When UnvanEki='Mrs.' or Unvaneki='Ms.' Then 'KadÄ±n'
When UnvanEki='Mr.' Then 'Erkek'
Else UnvanEki
End
from Personeller

--- EÄŸer Ã¼rÃ¼nÃ¼n birim fiyatÄ± 0-50 arasÄ± Ä°se 'Ã‡in MalÄ±',	50 -100 arasÄ± Ä°se 'Ucuz',	100-200 arasÄ± Ä°se 'Normal' ve 200' den fazla Ä°se 'PahalÄ±' yazsÄ±n.

select UrunAdi,
Case
When BirimFiyati>0 and BirimFiyati<50 Then 'Ã‡in MalÄ±'
When BirimFiyati between 50 and 100 Then 'Ucuz'
When BirimFiyati between 100 and 200 Then 'Normal'
When BirimFiyati>200 Then 'PahalÄ±'
Else 'Belirsiz'
End
from Urunler

--YukarÄ±daki Ã¶rnekte bir filtre yapmak istersek o zamanda SubQuery yÃ¶nremini kullanÄ±rdÄ±k Yani;

select * from (select UrunAdi,
Case
When BirimFiyati>0 and BirimFiyati<50 Then 'Ã‡in MalÄ±'
When BirimFiyati between 50 and 100 Then 'Ucuz'
When BirimFiyati between 100 and 200 Then 'Normal'
When BirimFiyati>200 Then 'PahalÄ±'
Else 'Belirsiz'
End as FiyatGrubu
from Urunler) as UrunEtiketli
where FiyatGrubu='Ã‡in MalÄ±'


--With Ties Komutu
-- Bu komut TOP komutu ile birlikte kullananÄ±labilir. amacÄ± Belli sayÄ±da bir sÄ±ralama yaparken Ã¶rneÄŸin  ilk 6 kaydÄ± getirmek istediÄŸimizde 6. kayÄ±ta eÅŸ deÄŸer bir veri varsa onlarÄ± getirmeyi saÄŸlar. Mesala bir yarÄ±ÅŸmada ilk 3 kiÅŸi belirleriz ancak 3. kiÅŸi ilede aynÄ± puanÄ± almÄ±ÅŸ yarÄ±ÅŸmacÄ±lar olabilir. Ä°ÅŸte bÃ¶yle bir istisna durumda with ties komuut bize yardÄ±mcÄ± olacaktÄ±r.

--With Ties komutu kullanÄ±yorsan sorgunun sonunda ORDER BY'da kullanmak zorundasÄ±n

Select * from [Satis Detaylari]

select top 6 with ties * from [Satis Detaylari] order by SatisID

 
--With Komutu

-- WITH komutu (CTE - Common Table Expression),
-- karmaÅŸÄ±k sorgularÄ± daha okunabilir hale getirmek iÃ§in kullanÄ±lÄ±r.
-- GeÃ§ici bir sonuÃ§ kÃ¼mesi oluÅŸturur ve bu kÃ¼me, sorgunun devamÄ±nda sanki bir tablo gibi davranÄ±r.
-- Tek bir kez tanÄ±mlanÄ±r ve birden fazla kez kullanÄ±labilir (sorgu iÃ§inde).
-- Alt sorgulara gÃ¶re daha temiz ve modÃ¼ler bir yapÄ± sunar.


With PersonelSatis(id,adi,soyadi,satisId)
as 
(
select p.PersonelID,p.Adi,p.SoyAdi,s.SatisID from Personeller p inner join Satislar s on p.PersonelID=s.PersonelID
)

--select * from PersonelSatis

select * from PersonelSatis ps inner join [Satis Detaylari] sd on ps.satisId=sd.SatisID


--- Subquery (iÃ§ iÃ§e Sorgular)
-- Ã–nemli UyarÄ±: Subquery'ile dÃ¶nen verinin tek satÄ±rda olamsÄ± gerekmektedir eÄŸer birden fazla satÄ±r dÃ¶nerse subquey Ã§alÄ±ÅŸmayacaktÄ±r.

select s.SatisTarihi,s.SatisID from Personeller p inner join Satislar s on p.PersonelID=s.PersonelID where p.Adi='Nancy'
 
 select s.SatisTarihi,s.SatisID from Satislar s where s.PersonelID=(select p.PersonelID  from Personeller p where p.Adi='Nancy')
 
 
 
 --- Bulk insert
 
 --Kisiler.txt
 -- Ad	Soyad	Unvan
-- OÄŸuzhan	Dilek	Full Stack Dev.
-- Zehra	Dilek	BebiÅŸ
-- SÃ¼tlaÃ§	Dilek	PiÅŸo

bulk insert Kisiler from 'D:\personal-repo\T-SQL-DERSLER-\Kisiler.txt'
with
(
Fieldterminator='\t',
RowTerminator='\n'
)

select * from Kisiler


--Truncate Komutu

--__Identity kolonunu sÄ±fÄ±rlar
--Test yapÄ±ldÄ±ktan sonra proje Publish edilemeden Ã¶nce test verilerini sÄ±fÄ±rlamak iÃ§in kullanÄ±labilir.

select * into PersonellerX from Personeller

truncate table PersonellerX


--@@Identity Komuutu

--Son yapÄ±lan Insert iÅŸleminin Identity deÄŸerini bir tabloda getirir

Insert into Kategoriler(KategoriAdi,Tanimi) values ('X','X Kategorisi')

select @@IDENTITY

Insert Personeller(Adi,SoyAdi) values('Husam','Candar')

--@@ROWCOUNT Komutu

--Herhangi bir iÅŸlemde (Select, Insert, Update vs) etkilenen kaÃ§ deÄŸer varsa onu dÃ¶ndÃ¼rÃ¼r

Delete from PersonellerX where Adi='Husam'
Select @@ROWCOUNT

Select * from Personeller
select @@ROWCOUNT

Insert PersonellerX(Adi,Soyadi) Values('Adam','Smith'),
										('Muhit','SS')
										select @@ROWCOUNT
										


--Identity Kolonuna MÃ¼dahale etme
--Ã–nmeli UyarÄ± Son Ä°dentity deÄŸerinde daha yÃ¼kesk bir deÄŸer girlmesi gerekir
DBCC Checkident(PersonellerX,reseed,27)




--NULL Kontrol MekanizmalarÄ±

-- Bu mekanizmalarÄ± null deÄŸerleri olan bir tabloda rapor hazÄ±rlarken kullanÄ±rÄ±z.

-- Case-Hhen-Then-E1se-End KalÄ±bÄ± Ä°le Null KontrolÃ¼

Select MusteriAdi, Bolge, 
Case
When Bolge IS NULL then 'BÃ¶lge Bilinmiyor'
else
Bolge
End
 from Musteriler

 ---- Coalesce Fonksiyonu Ä°le Null KontrolÃ¼

 select MusteriAdi, coalesce(Bolge,'BÃ¶lge Bilinmiyor')  from Musteriler
--Null KontrolÃ¼ yapÄ±lcak olan kolonun tipi ne ise ikinci parametrede o itpte olmalÄ±dÄ±r.

 -- IsNull Fonksiyonu Ä°le Null KontrolÃ¼

 select MusteriAdi, isnull(Bolge,'Bolge Bilinmiyor') from Musteriler
 --Null KontrolÃ¼ yapÄ±lcak olan kolonun tipi ne ise ikinci parametrede o itpte olmalÄ±dÄ±r.

 -- NullIf Fonksiyonu Ä°le Null KontrolÃ¼
-- Fonksiyona verilen kolon, Ä°kinci parametre verilen deÄŸere eÅŸit Ä°se o kolonu Null olarak getirir.

select nullif(1,2);
select nullif(0,0);

Select HedefStokDuzeyi from Urunler
Select AVG(HedefStokDuzeyi) from Urunler

--- Hedef stok dÃ¼zeyi O olmayan Ã¼rÃ¼nlerin ortalamasÄ± nedir?
Select AVG(HedefStokDuzeyi) from Urunler where HedefStokDuzeyi<>0
select AVG(nullif(HedefStokDuzeyi,0)) from Urunler 

--ONEMLÄ° RAPORLARDA KESÄ°NÄ°LKLE NULL DEÄERLERÄ° BOÅ BIRAKMAYIN!!'NULLIFF ile veya diÄŸer fonksiyonlarla bir ÅŸekilde belli edin yada hesaptan Ã§Ä±karÄ±lamsÄ±nÄ± saÄŸlayÄ±n. Aksi halde yanlÄ±ÅŸ hesap Ã§arÅŸÄ±dan dÃ¶ner


--- T -SQL ile VeritabanÄ±ndaki TablolarÄ± Listeleme

select * from sys.tables

--ya da

Select * from sysobjects where xtype='u'


--- Bir Tablonun Primary Key Olup OlmadÄ±ÄŸÄ±nÄ± Kontrol Etme

Select OBJECTPROPERTY(OBJECT_ID('Personeller'),'TableHasPrimaryKey')

-- EÄŸer sonuÃ§ 1 deÄŸerini dÃ¶ndÃ¼rÃ¼yrsa o zman tabloda primary key mevcuttur.








--DDl (Data Definition Language)
--- T-SQL de veritabanÄ± nesneleri oluÅŸturmamÄ±zÄ± saÄŸlayan ve bu nesneler Ã¼zerinde deÄŸiÅŸiklikler yapnamÄ±zÄ± ve silmenizi saÄŸlayan yapÄ±lar bu baÅŸlÄ±k altÄ±nda simgelenmektedir.
-- Create, Alter, Drop 

- ---CREATE---
-- VeritabanÄ± nesnesi oluÅŸturmamÄ±zÄ± saÄŸlar.(database,table,view,storedproc,trigger vs.)
-- Prototipi
--Create [Nesne] [Nesnenin Adi]
-- â€”Create Ä°le Database OluÅŸturma

Create Database OrnekVeriTabani

--- Bu ÅŸekilde bir kullanÄ±m varsayÄ±lan ayarlarda veritabanÄ± oluÅŸturacaktÄ±r.

Create Database OrnekVeriTabani
on
(
	Name='GG',
	Filename='D:\GG.mdf',
	Size=5,
	Filegrowth=3
)
-- Name : OluÅŸturulacak veritabanÄ±nÄ±n fiziksel ismini belirtiyoruz.
--- Filename : OluÅŸturulacak veritabanÄ± dosyasÄ±nÄ±n fiziksel dizinini belirtiyoruz.
--- Size : VeritabanÄ±nÄ±n baÅŸlangÄ±Ã§ boyutunu mb cinsinden ayarlÄ±yoruz.
--- Filegrowth : VeritabanÄ±nÄ±n boyutu, baÅŸlangÄ±Ã§ boyutunu geÃ§tiÄŸi durumda boyutun ne kadar artmasÄ± gerektiÄŸini mb cinsinden belirtiyoruz.


-- â€”Create Ä°le Log DosyasÄ±yla Birlikte Database OluÅŸturma

Create Database OrnekVeriTabani
on
(
	Name='GG',
	Filename='D:\GG.mdf',
	Size=5,
	Filegrowth=3
)
Log
on
(
	Name='GG_LOG',
	Filename='D:\GG.ldf',
	Size=5,
	Filegrowth=3
)

-- â€”Create Ä°le Tablo OluÅŸturma
USE OrnekVeriTabani

Create Table tablo1
(
	Kolon1 int,
	Kolon2 nvarchar(max),
	Kolon3 money
)

--- EÄŸer kolon adlarÄ±nda boÅŸluk varsa kÃ¶ÅŸeli parantez ile belirtilmelidir.

Create table tablo2
(
	[Kolon 1] int,
	[Kolon 2] nvarchar(50),
	[Kolon 3] money
)

--- â€”Kolona Primary Key ve Identity Ã¶zelliÄŸi KazandÄ±rmak

create table Tablo3
(
	Id int Primary key Identity (1,1),
	Kolon2 nvarchar(20)
)



---ALTER-----
-- Create ile oluÅŸturulan veritabanÄ± nesnelerinde deÄŸiÅŸiklik yapmamÄ±zÄ± saÄŸlar.
-- Prototip
-- Alter [Nesne] [Nesnenin Adi]
-- (YapÄ±ya GÃ¶re Ä°ÅŸlemler)

-- â€”Alter Ä°le Database GÃ¼ncelleme

Alter Database OrnekVeriTabani
Modify File
(
	Name='GG', --Name' i GG olan veritabanÄ±na gÃ¶re iÅŸem ayapar aslÄ±nda burada bir where var
	Size=20
)

--- â€”Alter Ä°le Olan Bir- Tablo 8 Kolon Ekleme

Alter Table tablo1
Add Kolon5 nvarchar(max)


--- Alter- Ä°le Tablodaki Kolonu GÃ¼ncelleme
Alter table tablo1
Alter Column Kolon4 int
--Not kolonda veri olmamasÄ± gerkiyor

-- â€”Alter Ä°le Tablodaki Kolonu Silme
Alter Table tablo1
Drop Column Kolon4

-- â€”Alter Ä°le Tabloya Constraint Ekleme

Alter Table tablo1
Add Constraint OrnekConstraint Default 'boÅŸ' for Kolon2

-- â€”Alter Ä°le Tabloya Constraint Silme

Alter Table tablo1
Drop Constraint OrnekConstraint 



-- SP_RENAME ile tablo adÄ± GÃ¼ncelleme

SP_RENAME 'tablo1','OrnekTablo'


-- SP_RENAME ile Kolon adÄ±  GÃ¼ncelleme

SP_RENAME 'OrnekTablo.Kolon1','Id','Column'

-- Create Ä°le oluÅŸturulan veri tabanÄ± nesnelerini silmemize yarar.
-- Prototip
--- Drop [Nesne] [Nesne AdÄ±]
Drop table OrnekTablo
Drop Database OrnekVeriTabani





-- Constraintler (KÄ±sÄ±tlayÄ±cÄ±lar)
-- Constraintler sayesinde tablolar Ã¼zerinde istediÄŸimiz ÅŸartlar ve durumlara gÃ¶re kÄ±sÄ±tlamalar yapabiliyoruz.
--DEFAULT CONSTRAINT
--CHECK CONSTRAINT
--PRÄ°MARY KEY CONSTRAINT
--UNIQUE COUSTRAINT
--FOREIGN KEY CONSTRAINT 


--- DEFAULT CONSTRAINT
--- Default ConstraÄ°nt sayesinde kolona bir deÄŸer girilmediÄŸi taktirde varsayÄ±lan olarak ne girilmesi gerektiÄŸini belirtebiliyoruz.
---- Genel YapÄ±sÄ±;
--- Add Constraint [Constraint AdÄ± ] Default 'VarsayÄ±lan DeÄŸer' For [Kolon AdÄ±]

create table OrnekTablo
(
Id int primary key identity(1,1),
Kolon1 nvarchar(max),
Kolon2 int
)

Alter Table OrnekTablo
Add Constraint Kolon1Constraint Default 'Bilgi Yok' For Kolon1

Alter Table OrnekTablo
Add Constraint Kolon2Constraint Default -1 For Kolon2


insert OrnekTablo(Kolon2) values(0)
insert OrnekTablo(Kolon1) values('Ã–rnek bir deÄŸer')

select * from OrnekTablo


--CHECK CONSTRAÄ°NT
-- Bir kolona girilecek olan verinin belirli bir ÅŸarta uymasÄ±nÄ± zorunlu tutar.
--- Genel YapÄ±sÄ±;
-- Add Constraint [Constraint AdÄ±] Check (ÅART)

Alter table OrnekTablo
Add Constraint Kolon2Kontrol Check ((Kolon2*5)%2=0)

-- Check ccnstraint oluÅŸturulmadan Ã¶nce ilgili tabloda ÅŸarta aykÄ±rÄ± deÄŸerler varsa eÄŸer	constraint oluÅŸturulmayacaktÄ±r !
-- Ancak Ã¶nceki kayÄ±tlarÄ± gÃ¶rmezden gelip genede Check ConstraintÄ° uygulamak Ä°stiyorsak	"WÄ°th Nocheck" komutu kullanÄ±lmalÄ±dÄ±r.
-- WÄ°th Nocheck Komutu
--- Åuana kadar olan kayÄ±tlarÄ± gÃ¶rmezden gelip, check constrainti uygulattÄ±rÄ±r.

Alter table OrnekTablo
--Drop Constraint Kolon2Kontrol
With Nocheck Add Constraint Kolon2Kontrol Check ((Kolon2*5)%2=0)

---PRIMARY KEY CONSTRAINT
--- Primary Key Constraint ile; o kolona eklenen primary key ile, baÅŸka tablolarda foreign key oluÅŸturarak iliÅŸki kurmamÄ±z mÃ¼mkÃ¼n olur.
--Bunun yanÄ±nda o kolonun taÅŸÄ±dÄ±ÄŸÄ± verinin tekil olacaÄŸÄ± da garanti edilmiÅŸ olur. Primary key constraint Ä°le ayrÄ±ca CLUSTERED index oluÅŸturulmuÅŸ da olur.
---- Genel YapÄ±sÄ±;
--- Add Constraint [Constraint AdÄ±] Primary Key (Kolon AdÄ±)

--DÄ°KKAT!!!
-- Primary Key Constraint kullanÄ±lan kolon primary key Ã¶zelliÄŸine sahip olmamalÄ±dÄ±r.

Alter table Ornektablo
Add Constraint PrimaryId Primary key (Id)


-- UNIQUE CONSTRAINT
-- Unique constraintin tek amacÄ±, belirttiÄŸimiz kolondaki deÄŸerlerin tekil olmasÄ±nÄ± saÄŸlamaktÄ±r.
-- Genel YapÄ±sÄ±;
--- Add ConstraÄ°nt [ConstraÄ°nt AdÄ±] Unique (Kolon AdÄ±)

Alter table Ornektablo
Add Constraint OrnekTabloUnique Unique (Kolon2)
--"Kolon2" kolonuna unique constraint verilerek tekil hale getirilmiÅŸtir. Bundan sonra ikitane aynÄ± veriden kayÄ±t yapÄ±lamamaktadÄ±r.

--- FOREIGN KEY CONSTRAINT
-- TablolarÄ±n kolonlarÄ± arasÄ±nda iliÅŸki kurmamÄ±zÄ± saÄŸlar. Bu iliÅŸki neticesinde; foreign key olan kolondaki karÅŸÄ±lÄ±ÄŸÄ±nÄ±n boÅŸa dÃ¼ÅŸmemesi Ä°Ã§in primary key kolonu olan tablodan veri silinmesini, gÃ¼ncellenmesini engeller.
-- Genel YapÄ±sÄ±;
--- Add Constraint [Constraint AdÄ±] Foreign Key (Kolon AdÄ±) References [2. Tablo AdÄ±] (2. Tablodaki Kolon AdÄ±)


create table Ogrenciler
(
OgrenciId int primary key identity(1,10),
DersId int,
Adi nvarchar(50),
Soyadi nvarchar(50)
)
create table Dersler
(
DersId int primary key identity(1,1),
DersAdi nvarchar(50)
)

Alter table Ogrenciler
Add Constraint ForeignKeyOgrenciDers Foreign key (DersId) References Dersler(DersId)

--- Åu durumda, delete ve update Ä°ÅŸlemlerinden Ä°liÅŸkili kolondaki veriler etkilenmez.
-- DavranÄ±ÅŸÄ± deÄŸiÅŸtirmek iÃ§in aÅŸaÄŸÄ±daki komutlar kullanÄ±lÄ±r.

--- -Cascade
---- Ana tablodaki kayÄ±t silindiÄŸinde ya da gÃ¼ncellendiÄŸinde, Ä°liÅŸkili kolondaki karÅŸÄ±lÄ±ÄŸÄ±da otomatik olarak silinir ya da gÃ¼ncellenir.

Alter Table Ogrenciler
Add Constraint ForeingKeyOgrenciDers Foreign Key (DersId) References Dersler(DersId)
ON DELETE CASCADE
ON UPDATE CASCADE

--- â€”Set Null
---- Ana tablodaki kayÄ±t silindiÄŸinde ya da gÃ¼ncellendiÄŸinde, iliÅŸkili kolondaki karÅŸÄ±lÄ±ÄŸÄ±na "Null" deÄŸer basÄ±lÄ±r.
Alter table Ogrenciler
add Constraint ForeignKeyOgrenciDers  Foreign Key (DersId) References Dersler(DersId)
ON Delete Set Null
ON Update Set Null

--- -Set Default
---- Ana tablodaki kayÄ±t silindiÄŸinde ya da gÃ¼ncellendiÄŸinde, iliÅŸkili kolondaki karÅŸÄ±lÄ±ÄŸÄ±na o kolonun default deÄŸeri basÄ±lÄ±r. Bu default deÄŸer dediÄŸimiz default tipte bir constrainttir. Bunu kendimiz oluÅŸturabiliriz.

Alter Table Ogrenciler
Add Constraint SetDefaultConstraint Default -1 For DersId

Alter Table Ogrenciler
Add Constraint ForeignKeyOgrenciDers Foreign key (DersId) References Dersler(DersId)
On Delete Set Default
On Update Set Default

--Dikkat !! Default deÄŸer aana tablodaki kaynaÄŸa gÃ¶re olamlÄ±dÄ±r . yukarÄ±daki Ã¶rnekte DersÄ±d iÃ§inde -1 deÄŸeri bulunmadÄ±ÄŸÄ± iÃ§in hata verecektir.

---- Bu ayarlar verilmediÄŸi taktirde "no action" Ã¶zelliÄŸi geÃ§erlidir.




--DeÄŸiÅŸkenler
-- Declare keywordÃ¼ Ä°le DeÄŸiÅŸken tanÄ±mlanÄ±r.
-- Prototip;
--- Declare @DegiskenAdi DegiskenTipi

declare @x int

declare @y nvarchar(50)

declare @z money

declare @x int, @y money, @z bit

declare @Yas int=3


-- TanÄ±mlanmÄ±ÅŸ DeÄŸiÅŸkenlere DeÄŸer Atama

declare @Adi nvarchar(50)='Zehra'

declare @x int

--SET

Set @x=125

declare @tarih datetime

Set @tarih=GETDATE()


-- DeÄŸiÅŸken DeÄŸeri Okuma

declare @x int
set @x=3
select @x
print @x

--Sorgu Sonucu Gelen Verileri DeÄŸiÅŸkenle Elde Etme

declare @Adi nvarchar(max), @Soyadi nvarchar(max)
Select @Adi=Adi,@Soyadi=SoyAdi  from Personeller where  PersonelID=1
Print @Adi+ ' ' + @Soyadi
-- 1. Sorgu sonucu gelen satÄ±r sayÄ±sÄ± bir adet olmalÄ±dÄ±r.
-- 2. Kolonlardaki verilerin tipleri ne ise c verileri temsil edecek deÄŸiÅŸkenlerin tipleride benzer olmalÄ±dÄ±r.






--Batch KavramÄ± - Go
-- yazÄ±lan kodlarÄ± farklÄ± iÅŸ parcÃ§acÄ±klarÄ±na ayrÄ±ldÄ±ÄŸÄ±nÄ± compailer'a ifade eden keyworddÃ¼r.

Create Database OrnekDatabase
Use OrnekDataBase
Create Table OrnekTable
(
 Id int primary key identity (1,1),
 Adi nvarchar(max),
 Soyadi nvarchar(max)
)

Insert Into OrnekTable Values('OÄŸuzhan','Dilek')
Select * from OrnekTable





--IF YapÄ±sÄ±

-- = : EÅŸitse
-- <> : EÅŸit DeÄŸilse
-- > : BÃ¼yÃ¼ktÃ¼r
-- < : KÃ¼Ã§Ã¼ktÃ¼r

--Tek SatÄ±rlÄ±k Ã‡alÄ±ÅŸma

Declare @Isim nvarchar(max)
Set @Isim='Dilek'

if @Isim='Dilek'
	print 'Evet'
Else
	Print 'HayÄ±r'

-- Begin-End YapÄ±sÄ± (Scope)
--KoÅŸu sonucu birden fazla iÅŸlem yapÄ±lacaksa Begin_end ile scoplanÄ±r.
declare @Sayi1 int=2, @Sayi2 int=5

if @Sayi1> @Sayi2
	Begin
		print 'Evet SayÄ±1 SayÄ±2 den BÃ¼yÃ¼ktÃ¼r'
		select @Sayi1 [SayÄ± 1], @Sayi2 [SayÄ± 2]
	End
Else
	Begin
		print 'HayÄ±r SayÄ±1 SayÄ±2 den kÃ¼Ã§Ã¼ktÃ¼r'
		select @Sayi1 [SayÄ± 1], @Sayi2 [SayÄ± 2]
	End

--Ã–rnek 1
--- MÃ¼ÅŸteriler tablosunda AmerikalÄ± (USA) mÃ¼ÅŸteri var mÄ±?
Use Northwind
select * from Musteriler where Ulke='USA'
if @@ROWCOUNT>0 
	print 'Evet'
Else
	Print 'HayÄ±r'

---- Ã–rnek 2
--- AdÄ± 'OÄŸuzhan'
--soyadÄ± 'Dilek' olan Personel var mÄ±? Varsa evet var desin. Yoksa kaydetsin.

Use Northwind
Declare @adi nvarchar(max)='Rumeysa', @soyadi nvarchar(max)='Dilek'
Select * from Personeller where Adi=@adi and SoyAdi=@soyadi
if @@ROWCOUNT>0
	print 'Evet Var'
Else
	Begin
	insert into Personeller(Adi,Soyadi) values(@adi,@soyadi)
	print 'hayÄ±r yok ama eklendi'
	End

--- If-Else If- Else YapÄ±sÄ±

declare @adi nvarchar(max)='OÄŸuzhan', @Yas int=33

if @adi='Mahmut'
	print 'evet'
Else if @Yas>24
	print 'Evet yaÅŸÄ± 24-ten bÃ¼yÃ¼k'
Else
	print 'hayÄ±r'



-- Exists Fonksiyonu
--Sorgu sonucu tablonun dolu mu boÅŸ mu olduÄŸunu dÃ¶ndÃ¼ren fonksiyondur

if Exists(Select * from Personeller)
	print 'True'
Else 
	Print 'False'
	

--While DÃ¶ngÃ¼sÃ¼

-- While Åart Komutu

declare @sayi int =0

while @sayi<=100
	Begin
		print @sayi
		set @sayi=@sayi+1
	End


--While DÃ¶ngÃ¼sÃ¼

-- Break Komutu

declare @sayi int =0

while @sayi<=100
	Begin
		print @sayi
		set @sayi=@sayi+1
		if @sayi%5=0
		break
	End
	
	--While DÃ¶ngÃ¼sÃ¼

-- Contiune Komutu

declare @sayi int =0

while @sayi<=100
	Begin
		if @sayi%5=0
			begin
				set @sayi=@sayi+1
				continue
		end
		print @sayi
		set @sayi=@sayi+1
	
	End
	
	
	
--- GeÃ§ici Tablolar - Temporary Tables

-- Genellikle bir SQL Server Ã¼zerinde farklÄ± lokasyonlarda birden fazla kiÅŸinin Ã§alÄ±ÅŸtÄ±ÄŸÄ± durumlarda ya da verilerin test amaÃ§lÄ± geÃ§ici bir yerlerde tutulmasÄ±, iÅŸlenmesi amacÄ±yla kullanÄ±lan yapÄ±lardÄ±r.
--- Bilinen tablo yapÄ±sÄ±nÄ±n aynÄ±sÄ±nÄ± saÄŸlarlar. Tek farklarÄ± fiziksel olarak oluÅŸmazlar. Sadece bellekte geÃ§ici olarak oluÅŸturulurlar.
--- Select, insert, Update ve Delete iÅŸlemleri yapÄ±labilir. Ä°liÅŸki kurulabilir.
-- Sunucu kapatÄ±ldÄ±ÄŸÄ±nda ya da oturum sahibi oturumu kapattÄ±ÄŸÄ±nda bellekten silinirler.


--- #Bir Tabloyu Fiziksel Olarak Kopyalama

Select * Into GeciciPersoneller from Personeller
--- Bu ÅŸekilde bir kullanÄ±mda sadece primary key ve foreign key constraintler oluÅŸturulmazlar. Geri kalan herÅŸey birebir fiziksel olarak oluÅŸturulur.

--- *Bir Tabloyu # Ä°fadesi Ä°le BelleÄŸe GeÃ§ici Olarak Kopyalama

select * into #GeciciPersoneller from Personeller

select * from #GeciciPersoneller
insert into #GeciciPersoneller(Adi,SoyAdi) values('Deli','Dolu')
Delete #GeciciPersoneller where Adi='Deli'
Update #GeciciPersoneller set SoyAdi='Manyak' where Adi='OÄŸuzhan'

--- GeÃ§ici tablo Ã¼zerinde her tÃ¼rlÃ¼ iÅŸlemi yapabiliyoruz I
---- # ile oluÅŸturulan tablo, o an SQL Serverda oturum aÃ§mÄ±ÅŸ kiÅŸinin sunucu belleÄŸinde oluÅŸur.
--- Sadece oturum aÃ§an ÅŸahÄ±s kullanabilir.
--- EÄŸer oturum aÃ§an ÅŸahÄ±s SQL Servardan disccnnet olursa bu tablo bellekten silinir.



-- *Bir Tabloyu ## Ä°fadesi Ä°le BelleÄŸe GeÃ§ici Olarak Kopyalama

select * into ##GeciciPersoneller from Personeller

insert into  ##GeciciPersoneller(Adi,SoyAdi) values('Deli','Dolu')
Delete ##GeciciPersoneller where Adi='Deli'
Update ##GeciciPersoneller set SoyAdi='Manyak' where Adi='OÄŸuzhan'
select * from ##GeciciPersoneller

--- ## ile oluÅŸturulan tablo, o an SQL Servarda oturum aÃ§mÄ±ÅŸ kiÅŸinin sunucu belleÄŸinde oluÅŸur.
---- Bu tabloyu oturum aÃ§an ÅŸahÄ±s ve onun SQL ServarÄ±na dÄ±ÅŸardan ulaÅŸan 3. ÅŸahÄ±slar kullanabilir.
--- EÄŸer oturum aÃ§an ÅŸahÄ±s SQL Servardan disccnnet olursa bu tablo bellekten silinir.
--- DiÄŸer bÃ¼tÃ¼n Ã¶zellikleri # Ä°le oluÅŸturulan tablo Ä°le aynÄ±dÄ±r.


-- Uniqueidentifier Veri TÄ°PÄ°
-- inti varchar vs. gibi bir veri tipidir.
--- AldÄ±ÄŸÄ± deÄŸer, rakamlar ve harflerden oluÅŸan Ã§ok bÃ¼yÃ¼k bir sayÄ±dÄ±r.
-- Bundan dolayÄ± bu kolona aynÄ± deÄŸerin birden fazla gelmesi neredeyse imkansÄ±zdÄ±r.
--- O yÃ¼zden tekil bir veri oluÅŸturmak iÃ§in kullanÄ±lÄ±r.

USe OrnekVeriTabani
create table ornektable
(
Id int primary key identity(1,1),
FirstName nvarchar(50),
MailCode uniqueidentifier 

)

--NEWID() Fonksiyonu
insert into ornektable values('OÄŸuzhan',NEWID())

select * from ornektable




---- View YapÄ±sÄ±
--KullanÄ±m
--Genellikle karmaÅŸÄ±k sorgularÄ±n tek bir sorgu Ã¼zerinden Ã§alÄ±ÅŸtÄ±rÄ±labilmesidir.
---- Bu amaÃ§la raporlama iÅŸlemlerinde kullanÄ±labilirler.
--- AynÄ± zamanda gÃ¼venlik ihtiyacÄ± olduÄŸu durumlarda herhangi bir sorgunun 2. - 3. ÅŸahÄ±slardan gizlenmesi amacÄ±yla da kullanÄ±lÄ±rlar.
--- Genel Ã–zellikleri
--Herhangi bir sorgunun sonucunu tablo olarak ele alÄ±p, ondan sorgu Ã§ekilebilmesini saÄŸlarlar.
---- ***Ã–nemli***insert, Update ve Delete yapabilirler. Bu iÅŸlemleri fiziksel tabloya yansÄ±tÄ±rlar. 
---- View yapÄ±larÄ± fiziksel olarak oluÅŸturulan yapÄ±lardÄ±r.
---- View yapÄ±larÄ± normal sorgulardan daha yavaÅŸ Ã§alÄ±ÅŸÄ±rlar.
--Dikkat !
---- Database elemanlarÄ±nÄ± Create komutuyla oluÅŸturuyorduk. View yapÄ±sÄ±da bir database yapÄ±sÄ± olduÄŸu Ä°Ã§in Create komutu Ä°le oluÅŸturacaÄŸÄ±z.

Create View vw_Gotur
As
Select p.Adi+' '+p.SoyAdi [AdÄ± SoyadÄ±],k.KategoriAdi [Kategori AdÄ±], COUNT(s.SatisID) [Toplam SatÄ±ÅŸ] from Personeller p inner join Satislar s on p.PersonelID=s.PersonelID
							inner join [Satis Detaylari] sd on s.SatisID=sd.SatisID
							inner join Urunler u on sd.UrunID=u.UrunID
							inner join Kategoriler k on k.KategoriID=u.KategoriID
							group by p.Adi+' '+p.SoyAdi, k.KategoriAdi 

select * from vw_Gotur

select * from vw_Gotur where [AdÄ± SoyadÄ±] Like '%Robert%'

-- View oluÅŸturulurken kolonlara verilen aliaslar View'den sorgu Ã§ekilirken kullanÄ±lÄ±r.
-- Bir yandan da view'Ä±n kullandÄ±ÄŸÄ± gerÃ§ek tablolarÄ±n kolon isimleri, View iÃ§inde alias tanÄ±mlanarak gizlenilmiÅŸ olunur.
-- View iÃ§inde "order by- kullanÄ±lamaz.
--"Order By" view iÃ§inde deÄŸil, view Ã§alÄ±ÅŸÄ±rken sorgu esnasÄ±nda kullanÄ±lmalÄ±dÄ±r.
Select * from vw_Gotur order by [Toplam SatÄ±ÅŸ]
-- Yok eÄŸer Ä°llaki ben View Ä°Ã§inde "order by" kullanacaÄŸÄ±m diyorsanÄ±z View iÃ§inde "top" korutunu kullanmalÄ±sÄ±nÄ±z.
--- Bu durun Ã§okta tavsiye edilen bir durum deÄŸildir.

-- View Ã¼zerinde insert. Delete ve Update yapÄ±labilir. Bu iÅŸlemler fiziksel tabloya yansÄ±tÄ±lmaktadÄ±rlar.

Create View OrnekViewPersoneller
As
Select Adi,SoyAdi,Unvan from Personeller

Insert Into OrnekViewPersoneller(Adi,SoyAdi,Unvan) values('Faruk','Aslan','Senior DEV')
Update OrnekViewPersoneller set SoyAdi='Karaslan' where SoyAdi='Aslan'
Delete OrnekViewPersoneller where SoyAdi='Karaslan'
Select * from Personeller

--- WÄ°th EncryptÄ°on Komutu
--- EÄŸer yazdÄ±ÄŸÄ±mÄ±z view'in kaynak kodlarÄ±nÄ±, Object Explorer penceresinde "Views" kategorisine saÄŸ tÄ±klayarak Design Mdda aÃ§Ä±p
--gÃ¶rÃ¼ntÃ¼lenmesini istemiyorsak "With Encryption" komutu Ä°le Viewi oluÅŸturmalÄ±yÄ±z.
--- Dikkat !
--"With Encryption" iÅŸleminden sonra vÄ°ew'Ä° oluÅŸturan kiÅŸide dahil kimse komutlarÄ± gÃ¶remez. Geri dÃ¶nÃ¼ÅŸ yoktur. Ancak view'i oluÅŸturan ÅŸahsÄ±n komutlarÄ±n yedeÄŸini bulundurmasÄ± gerekmektedir. Ya da "With Encryption" olmaksÄ±zÄ±n view yapÄ±sÄ±nÄ± yeniden alterlamalÄ±yÄ±z.
--- Dikkat !
--- Bir dikkat etmemiz gereken nokta da "With Encryption" ifadesini "as" keywordÃ¼nden Ã¶nce yazmalÄ±yÄ±z.

create view OrnekViewPersoneller 
With Encryption
as
Select Adi,SoyAdi,Unvan from Personeller
--- Bu iÅŸlemi yaptÄ±ktan sonra Design Modu kapatÄ±lmÄ±ÅŸtÄ±r.


---- WÄ°th Schemabinding Komutu
--- EÄŸer view'in kullandÄ±ÄŸÄ± esas fiziksel tablolarÄ±n kolon isimleri bir ÅŸekilde deÄŸiÅŸtirilir, kolonlarÄ± silinir ya da tablo yapÄ±sÄ± bir ÅŸekilde deÄŸiÅŸikliÄŸe uÄŸrar ise vÄ°ew'Ä°n Ã§alÄ±ÅŸmasÄ± artÄ±k mÃ¼mkÃ¼n olmayacaktÄ±r.
---- View'in kullandÄ±ÄŸÄ± tablolar ve kolonlarÄ± bu tarz iÅŸlemler yapÄ±labilmesi ihtimaline karÅŸÄ± koruma altÄ±na alÄ±nabilir.
---- Bu koruma "With Schemabinding" komutu ile yapÄ±labilir.
--"With Schemabinding" ile view Create ya da Alter edilirken, view'in kullandÄ±ÄŸÄ± tablo, schema adÄ±yla birlikte verilmelidir. Ã¶rneÄŸin, dbo(database owner) bir ÅŸema adÄ±dÄ±r. Åemalar C#'takÄ° namespaceler gibi dÃ¼ÅŸÃ¼nÃ¼lebilir.
----"With Schemabinding" konutuda "As" keywordÃ¼nden Ã¶nce yazÄ±lmalÄ±dÄ±r.

Create Table OrnekTablo
(
 Id int primary key identity(1,1),
 FirstName nvarchar(50),
 Kolon int
)

Create View OrnekViewTablo
With Schemabinding
as
Select Id,FirstName,Kolon from dbo.OrnekTablo

Alter Table OrnekTablo
Alter Column Kolon nvarchar(50)


--- With Check Option Komutu
-- View'in iÃ§erisindeki sorguda bulunan ÅŸarta uygun kayÄ±tlarÄ±n insert edilmesine mÃ¼sade edilip, uymayan kayÄ±tlarÄ±n mÃ¼sade edilmemesini saÄŸlayan bir konuttur.

--"With Encryption" ve "With Schemabinding" komutlarÄ± "As" keywordÃ¼nden Ã¶nce belirtilirken "With Check Option" komutu where ÅŸartÄ±ndan sonra belirtilmelidir.

Create View OrnekViewTabo2
As
Select Id,FirstName,Kolon from OrnekTablo where FirstName like'A%'
With Check Option

Insert OrnekViewTabo2 values('OÄŸuzhan',1) --Eklenemez

Insert OrnekViewTabo2 values('Ahmet',1)--Eklendi









--- Functions - Scalar Function - inline Function

--T -SQL 'de iki tip fonksiyon vardÄ±r.
--Scalar Fonksiyonlar Geriye istediÄŸimiz bir tipte deÄŸer gÃ¶nderen fonksiyon.
--- inline Fonksiyonlar Geriye tablo gÃ¶nderen fonksiyon.

--Bu her iki fonksiyonda fiziksel olarak veritabanÄ±nda oluÅŸturulmaktadÄ±r.
--Create komutu ile oluÅŸturulmaktadÄ±r.
--- Ãœzerinde Ã§alÄ±ÅŸÄ±lan database'in Programmability -> Functions kombinasyonundan oluÅŸturulan fonksiyonlara eriÅŸebilmekteyiz.


--â€” 1. Scalar Function â€”
---- Fonksiyon TanÄ±mlama
--- Scalar fonksiyonlara tanÄ±mlandÄ±ktan sonra Programmability Functions Scalar- valued Functions kombinasyonundan eriÅŸilebilir.
USE Northwind
Create Function Topla(@Sayi1 int, @Sayi2 int) Returns int 
As
	Begin
		return @Sayi1 + @Sayi2
	End
--OluÅŸturulan bu fonksiyonu dÃ¼zeltmek isterseniz Programmability->Sclar-valued Functions klasÃ¶rÃ¼nden ismin Ã¼zerine gelip saÄŸ tÄ±klayÄ±nca Modify seÃ§ilerek dÃ¼zeltme yapÄ±labilir.

--- Fonksiyon KullanÄ±mÄ±
--- Fonksiyonu kullanÄ±rken ÅŸemasÄ±yla beraber Ã§aÄŸrÄ±lmalÄ±dÄ±r.

select dbo.Topla(2,1)
print dbo.Topla(3,5)

--Ã–rnek
--"Northwindâ€ veri tabanÄ±nda; herhangi bir Ã¼rÃ¼nÃ¼n %18 KDV dahil olmak Ã¼zere toplam maliyetini getiren fonksiyonu yazalÄ±m.

Create Function Maliyet(@BirimFiyati int, @StokMiktari int) Returns nvarchar(max)
As
	Begin
		declare @sonuc int=@BirimFiyati*@StokMiktari*1.18
		return @sonuc
	End
Select dbo.Maliyet(10,20)


--2. inline Function
--- Geriye bir deÄŸer deÄŸil, tablo gÃ¶nderen fonksiyonlardÄ±r.
--Geriye tablo gÃ¶ndereceÄŸi iÃ§in bu fonksiyonlar Ã§alÄ±ÅŸtÄ±rÄ±lÄ±rken sanki bir tablodan sorgu Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r gibi Ã§alÄ±ÅŸtÄ±rÄ±lÄ±rlar. Bu yÃ¶nleriyle viewlara benzerler. View ile yapÄ±lan iÅŸlevler inline Functions â€¢ lapla yapÄ±labilir.
--Genellikle viewle benzer iÅŸlevler iÃ§in View kullanÄ±lmasÄ±nÄ± Ã¶neririm.

--- Fonksiyon TanÄ±mlama
--- inline fonksiyonlara tanÄ±mlandÄ±ktan sonra Programmability -> Functions->Table-valued Functions kombinasyonundan eriÅŸilebilir.
--Dikkat !
--- inline Function oluÅŸturulurken Begin End yapÄ±sÄ± kullanÄ±lmaz.

Create Function fc_Gonder(@Ad nvarchar(20), @Soyad nvarchar(20)) Returns Table
As
	return Select Adi,Soyadi from Personeller where Adi=@Ad and SoyAdi=@Soyad

--Fonksiyon KullanÄ±mÄ±
--- Fonksiyonu ÅŸemasÄ±yla birlikte Ã§aÄŸÄ±rmak gerekmektedir.
select * from dbo.fc_Gonder('OÄŸuzhan','Dilek')


---- Fonksiyonlarda With Encryption Komutu
--EÄŸer ki yazmÄ±ÅŸ olduÄŸumuz fonksiyonlarÄ±n kodlarÄ±na 2. 3. ÅŸahÄ±slarÄ±n eriÅŸimini engellemek istiyorsak â€With Encryption" komutunu kullanmalÄ±yÄ±z.
--â€With Encryptionâ€ iÅŸleminden sonra fonksiyonu oluÅŸturan kiÅŸide dahil kimse komutlarÄ± gÃ¶remez. Geri dÃ¶nÃ¼ÅŸ yoktur. Ancak fonksiyonu oluÅŸturan ÅŸahsÄ±n komutlarÄ±n yedeÄŸini bulundurmasÄ± gerekmektedir. Ya da "With Encryptionâ€ olmaksÄ±zÄ±n fonksiyonu yeniden alterlamalÄ±yÄ±z.
--"With Encryption" "As" key wordÃ¼nden Ã¶nce kullanÄ±lmalÄ±dÄ±r.

Create function OrnekFunc() Returns int
With Encryption
As
	Begin
	return 3
	End
Go
Select dbo.OrnekFunc()

Create function OrnekFunc2() Returns Table
With Encryption
As
	Return select * from Personeller

select * from dbo.OrnekFunc2()

--Encryption ettiÄŸimiz fonksiyonlarÄ± Alter ile Encryption'larÄ±nÄ± kaldÄ±ryoruz

Alter Function OrnekFunc() Returns int
as
	Begin
		return 3
	End

Alter function OrnekFunc2() Returns Table
As
	return Select * from Personeller


---- Otomatik Hesaplanabilir Kolonlar - Computed Column
--- Herhangi bir kolonda fonksiyon kullanÄ±larak otomatik hesaplanabilir kolonlar
--(Computed Column) oluÅŸturmak mÃ¼mkÃ¼ndÃ¼r.

Create function Topla(@Sayi1 int, @Sayi2 int) returns int
as
	Begin
		return @Sayi1+@Sayi2
	End
Select UrunAdi, dbo.Topla(BirimFiyati,HedefStokDuzeyi) HesapnamisKolon  from Urunler
--Ã–rnek:
--Ã‡Ä±ktÄ± olarak "_____kategorisindeki ____Ã¼rÃ¼nÃ¼nÃ¼n toplam fiyatÄ± __' dÄ±r. "ÅŸeklinde bir Ã§Ä±ktÄ± veren fonksiyonu yazalÄ±m.
Create function Rapor(@Kategori nvarchar(max),@UrunAdi nvarchar(max), @BirimFiyati int, @Stok int) Returns nvarchar(max)
As
	Begin
		declare @Cikti nvarchar(max) = @Kategori + ' kategorisindeki ' + @UrunAdi + ' Ã¼rÃ¼nÃ¼n toplam fiyatÄ± ' + CAST(@BirimFiyati*@Stok as nvarchar(max)) + 'dÄ±r.'  
		return @Cikti
	End

Select dbo.Rapor(k.KategoriAdi,u.UrunAdi,u.BirimFiyati,u.HedefStokDuzeyi) From Urunler u join Kategoriler k on u.UrunID=k.KategoriID








----- Stored Procedures (SaklÄ± Yordamlar)
------ Genel Ã–zelliklerÄ±

----Normal sorgulardan daha hÄ±zlÄ± Ã§alÄ±ÅŸÄ±rlar.
----Ã‡Ã¼nkÃ¼ normal sorgular Execute edilirken "Execute Planâ€ iÅŸlemi yapÄ±lÄ±r. Bu iÅŸlem sÄ±rasÄ±nda hangi tablodan veri Ã§ekilecek, hangi kolonlardan gelecek, bunlar nerede v.s gibi iÅŸlemler yapÄ±lÄ±r. Bir sorgu her Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda bu iÅŸlemler aynen tekrar tekrar yapÄ±lÄ±r. Fakat sorgu Stored Procedure olarak Ã§alÄ±ÅŸtÄ±rÄ±lÄ±rsa bu iÅŸlem sadece bir kere yapÄ±lÄ±r ve o da ilk Ã§alÄ±ÅŸtÄ±rma esnasÄ±ndadÄ±r. DiÄŸer Ã§alÄ±ÅŸtÄ±rmalarda bu iÅŸlemler yapÄ±lmaz. Bundan dolayÄ± hÄ±z ve performansta artÄ±ÅŸ saÄŸlanÄ±r.
----Ä°Ã§erisinde Select, insert, Update ve Delete iÅŸlemleri yapÄ±labilir.
----iÃ§ iÃ§e kullanÄ±labilir.
----Ä°Ã§lerinde fonksiyon olutÅŸrulabilir.
----- SorgularÄ±mÄ±zÄ±n dÄ±ÅŸarÄ±dan alacaÄŸÄ± deÄŸerler parametre olarak Stored Procedure' lere geÃ§irilebildiÄŸinden dolayÄ±, sorgularÄ±mÄ±zÄ±n "SQL Injectionâ€ yemelerinide Ã¶nlemiÅŸ oluruz. Bu yÃ¶nleriyle de daha gÃ¼venlidirler.
----- Stored Procedure fiziksel bir veritabanÄ± nesnesidir. Haliyle Create komutu ile oluÅŸturulur.
----- Fiziksel olarak ilgili veritabanÄ±nÄ±n "Programmabilityâ€ "Stored Procedures" kombinasyonundan eriÅŸilebilirler.

--Prototip -
--- Create Proc ya da Procedure [Ä°sim]
--(
--varsa parametreler
--)
--yazÄ±lacak sorgular, kodlar, ÅŸartlar,fonksiyonlar,komutlar



-- Stored Procedure TanÄ±mlama

Create Proc sp_Ornek
(
	@Id int --Aksi sÃ¶ylenmediÄŸi taktirde bu parametrenin yapÄ±sÄ± inputtur.
)
As
Select * from Personeller where PersonelID=@Id
--Dikkat !
--- ProsedÃ¼rÃ¼n parametrelerini tanÄ±mlarken parantez kullanmak zorunlu deÄŸildir ama okunabilirliÄŸi arttÄ±rmak iÃ§in kullanmakta fayda vardÄ±r.

Create Procedure sp_Ornek2
	@Id int,
	@Parametre1 int,
	@Parametre2 nvarchar(max)
As
Select * from Personeller where PersonelID=@Id

---- Stored Procedure KullanÄ±mÄ±
--- Stored Procedure yapÄ±larÄ±nÄ± "Exec" komutu eÅŸliÄŸinde Ã§alÄ±ÅŸtÄ±rabilmekteyiz.

Exec sp_Ornek 3

Exec sp_Ornek2 4,4,'ASD'


-- Geriye DeÄŸer DÃ¶ndÃ¼ren Stored Procedure YapÄ±sÄ±

Create Proc urunGetir
(
	@Fiyat money
)
As
Select * from Urunler where BirimFiyati>@Fiyat
Return @@Rowcount

--KullanÄ±mÄ±
Exec urunGetir 40
--Bu ÅŸekilde geriye dÃ¶nÃ¼len deÄŸeri elde etmeksizin kullanÄ±labilir. SÄ±kÄ±ntÄ± olmaz.

Declare @Sonuc int
Exec @Sonuc=urunGetir 40
print CAST(@Sonuc as nvarchar(max))+ ' adet Ã¼rÃ¼n iÅŸlemden etkilenmiÅŸitr'
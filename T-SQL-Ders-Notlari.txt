T-SQL DERSLERÄ°

ServerName alanÄ± iÃ§in "." localhost ve (local) yazmanÄ±z aynÄ± ÅŸeyler ifade eder.

localhostta yenii bir veritabanÄ± oluÅŸurmak iÃ§in CMD  satÄ±rÄ±na localdb create veritabaniAdi yazmanÄ±z yeterli.
 Daha sonra Managment Sever Name alanÄ±na (local)\veritabaniAdi yazarak baÄŸlanabilirisniz.
 
 
 
 
 
 --SELECT KOMUTU
select 3

select 3,5,7

select 'OÄŸuzhan'

print 'Dilek'

select * from Northwind.dbo.Personeller

select Adi, SoyAdi from Northwind.dbo.Personeller

--  ALIAS ATAMA
Select Adi AdÄ±, SoyAdi Soyisimler from Northwind.dbo.Personeller

-- BoÅŸluk Karakteri Olan Alias atama

select 1453 [Ä°stanbulun Fethi]


-- BoÅŸluk Karakteri Olan Tablo Sorgulama

select * from Northwind.dbo.[Satis Detaylari]

-- KolonlarÄ± BirleÅŸtirme

Select Adi+' '+ SoyAdi [Ä°sim  ve Soyisimler]  from Northwind.dbo.Personeller

-- FarklÄ± Tipte kolon BirleÅŸtirme

Select Adi+' '+ CONVERT(nvarchar,IseBaslamaTarihi) [Ä°ÅŸe BaÅŸlama Tarihleri] from Northwind.dbo.Personeller

Select Adi+' '+ CAST(IseBaslamaTarihi as nvarchar) [Ä°ÅŸe BaÅŸlangÄ±Ã§]  from Northwind.dbo.Personeller







USE Northwind

-- SELECT SORGULARÄ±NDA (WHERE) ÅARTÄ± YAZMAK

select * from dbo.Personeller

select * from dbo.Personeller where Sehir='London'

select * from dbo.Personeller where BagliCalistigiKisi<5

--And OperatÃ¶rÃ¼
-- Personeller tablosunda ÅŸehri london ve Ã¼lkesi UK olanlarÄ± listeleyelim.

select * from dbo.Personeller where Sehir='London' and Ulke='UK'

-- Or OperatÃ¶rÃ¼
-- Personeller tablosunda UnvanEki 'MC.' olan veya ÅŸehri Seattle olan tÃ¼m personelleri listeleyelim.

select * from dbo.Personeller where UnvanEki='Mr.' or  Sehir='Seattle'

--KarÅŸÄ±k Ã–rnekler
--AdÄ± Robert soyadÄ± King olan personelin tÃ¼m bilgilerini Ã§ek.

select * from dbo.Personeller where Adi='Robert' and SoyAdi='King'

-- PersonellD'si 5 olan personeli getir.
select * from dbo.Personeller where PersonelID=5

-- PersonellD'si 5 'ten bÃ¼yÃ¼k olan tÃ¼m personelleri getir.

select * from dbo.Personeller where PersonelID>=5

-- <> EÅŸit DeÄŸilse
-- = EÅŸitse
-- <= KÃ¼Ã§Ã¼k ve EÅŸitse
-- >= BÃ¼yÃ¼k ve EÅŸitse

-- Fonksiyon SonuÃ§larÄ±nÄ± ÅŸart Olarak Kullanmak
--- 1993 yÄ±lÄ±nda Ä°ÅŸe baÅŸlayanlarÄ± listele.

select * from dbo.Personeller where year(IseBaslamaTarihi)=1993

--- 1992 yÄ±lÄ±ndan sonra iÅŸe baÅŸlayanlarÄ± listele.

select * from dbo.Personeller where YEAR(IseBaslamaTarihi)>1992

-- DoÄŸum gÃ¼nÃ¼, ayÄ±n 29 olan personelleri listeleyelim.

select *from dbo.Personeller where Day(DogumTarihi)=29

--DoÄŸum yÄ±lÄ± 1950 ile 1965 yÄ±llarÄ± arasÄ±nda olan personelleri getirelim.

select * from dbo.Personeller where YEAR(DogumTarihi)>1950 and YEAR(DogumTarihi)<1965

--- YaÅŸadÄ±ÄŸÄ± ÅŸehrin Lcndon, Taccma ve Kirkland olan personellerin adÄ±nÄ± listeleyelim.

select Adi AdÄ± from dbo.Personeller where Sehir='London' or Sehir='Kirkland' or sehir='Tacoma'

---Between Komutu
select * from dbo.Personeller where YEAR(DogumTarihi)>1950 and YEAR(DogumTarihi)<1965

select * from dbo.Personeller where YEAR(DogumTarihi) between 1950 and 1965

select * from dbo.Personeller where PersonelID between 2 and 5

--In Komutu

 select Adi Ä°simler from dbo.Personeller where Sehir='London' or Sehir='Tacoma' or Sehir='Kirkland'

 select Adi isimler from dbo.Personeller where Sehir in('London','Tacoma','Kirklanda')

 select Adi AdÄ±, DogumTarihi [DoÄŸum Tarihi] from  dbo.Personeller where YEAR(DogumTarihi) in(1948,1963)
 
 
 
 
 
 
 
 Use Northwind
 -- LIKE SORGULARÄ±
-- % (Genel Ã–nemli DeÄŸil) OperatÃ¶rÃ¼

-- Ä°sminin baÅŸ harfi j olan personellerin adÄ±nÄ± ve soyadÄ±nÄ± yazdÄ±ralÄ±m.

select Adi AdÄ±, Soyadi SoyadÄ±  from dbo.Personeller where Adi like('j%')

-- Ä°sminin son harfi y olan personellerin adÄ±nÄ± ve soyadÄ±nÄ± yazdÄ±ralÄ±m.

select Adi Ä°sim, SoyAdi Soyisim from dbo.Personeller where Adi like '%y'

--- Ä°sminin son Ã¼Ã§ harfi ert olan personeli getirelim.

select Adi,Soyadi from dbo.Personeller where Adi like '%ert'

--- Ä°sminin ilk harfi r, son harfi t olan personeli getirelim.

select Adi,Soyadi from dbo.Personeller where Adi like 'r%t'

-- Gereksiz bir kullanÄ±m.
select Adi,Soyadi from dbo.Personeller where Adi like 'r%' and Adi like'%t'

--- Ä°sminde an geÃ§en personelin adÄ±nÄ± yazdÄ±ralÄ±m.

select Adi,Soyadi from dbo.Personeller where Adi like '%an%'

--- Ä°sminin baÅŸ harfi n olan ve Ä°Ã§erisinde an geÃ§en personeli getirelim.

select Adi,Soyadi from dbo.Personeller where Adi like 'n%an%'

-- Gereksiz bir kullanÄ±m.

select Adi,Soyadi from dbo.Personeller where Adi like 'n%' and Adi like'%an%'



-- _(Ã¶zel Onemli DeÄŸil) OperatÃ¶rÃ¼

-- Ä°sminin ilk harfi a, ikinci harfi fark etmez ve Ã¼Ã§Ã¼ncÃ¼ harfi d olan personeli getirelim.

select * from dbo.Personeller where Adi like 'a_d%'

-- Ä°sminin ilk harfi m, ikinci -Ã¼Ã§Ã¼ncÃ¼ - dÃ¶rdÃ¼ncÃ¼ fark etmez ve beÅŸinci harfi a olan personeli getirelim.

select * from dbo.Personeller where Adi like 'm___a%'

--[](ya da) OperatÃ¶rÃ¼

-- Ä°sminin ilk harfi n ya da m ya da r olan personelleri getirelim.

select * from dbo.Personeller where Adi like '[nmr]%'

-- Ä°sminin Ä°Ã§erisinde a ya da Ä° geÃ§en personelleri getirelim.

select * from dbo.Personeller where Adi like '%[ai]%'

-- [*-*] (Alfabetik ArasÄ±nda) OperatÃ¶rÃ¼

--- Ä°sminin baÅŸ harfi a Ä°le k arasÄ±nda alfabetik sÄ±raya gÃ¶re herhangi bir harf olan personellerin adÄ±nÄ± yazdÄ±ralÄ±m.

select * from dbo.Personeller where Adi like '[a-k]%'


-- [^*] (DeÄŸil) OperatÃ¶rÃ¼

--- Ä°sminin baÅŸ harfi a olmayan personelleri getirelim.

select *from dbo.Personeller where Adi like '[^a]%'

--- Ä°sminin baÅŸ harfi a ya da n olmayan personelleri getirelim.

select * from dbo.Personeller where Adi like '[^an]%'

-- Escape(KaÃ§Ä±ÅŸ) Karakterleri
-- Like sorgularÄ±nda kullandÄ±ÄŸÄ±mÄ±z %, _ , [] gibi Ã¶zel ifadeler eÄŸer ki verilerimiz iÃ§erisinde geÃ§iyorsa sorgulama esnasÄ±nda hata Ä°le karÅŸÄ±laÅŸabiliriz. BÃ¶yle durumlarda bu ifadelerin Ã¶zel ifade olmadÄ±ÄŸÄ±nÄ± escape karakterleri Ä°le belirleyebiliriz.
-- [] OperatÃ¶rÃ¼ Ä°le
-- Escape Komutu Ä°le

 select * from dbo.Personeller where Adi like '[_]%'

 select  Adi,Soyadi from dbo.Personeller where SoyAdi like 'n%%' escape 'n'
 
 select  Adi,Soyadi from dbo.Personeller where SoyAdi like 'n%%' escape 'n' --n kaÃ§Ä±ÅŸÄ±n baÅŸlangÄ±Ã§ alias gibi dÃ¼ÅŸÃ¼nebiliriz n den bir sonraki keyword deÄŸil demek 
 
 
 
 
 
 --AGGREGATE FONKSÄ°YONLAR

-- AVG : Ortlama AlÄ±r

select AVG(PersonelID) PersonelIdOrtalamasi from .dbo.Personeller

select AVG(BirimFiyati) [Birim FiyatÄ± Ort] from dbo.[Satis Detaylari]

--MAX: En BÃ¼yÃ¼k DeÄŸeri Bulur

select max(miktar) Miktar from dbo.[Satis Detaylari]

--MIN : En KÃ¼Ã§Ã¼k DeÄŸeri Bulur

select min(miktar) Miktar from dbo.[Satis Detaylari]

-- COUNT: Toplam kayÄ±t SaysÄ±nÄ± Verir

select COUNT(*) from dbo.Personeller

select count(Adi) [KayÄ±t SayÄ±sÄ±] from dbo.Personeller

-- SUM: ToplamÄ±nÄ± Verir

select sum(nakliyeUcreti) nakliyeUcreti from dbo.[Satislar]







--STRING FONKSÄ°YONLAR

-- LEFT :Soldan(baÅŸtan) belirtilen sayÄ±da karakteri getirir.
Select Adi, LEFT(Adi,2) from dbo.Personeller

-- RÄ°GHT : SaÄŸdan(sondan) belirtilen sayÄ±da karakteri getirir.

select Adi, RIGHT(Adi,2) from dbo.Personeller

-- UPPER :BÃ¼yÃ¼k harfe Ã§evirir.

select UPPER(Adi) from dbo.Personeller

select left(UPPER(Adi),3) from dbo.Personeller

-- UPPER :BÃ¼yÃ¼k harfe Ã§evirir.

select UPPER(SoyAdi) from dbo.Personeller

-- SUBSTRING : Belirtilen indexten itibaren belirtilen sayÄ±da karakter getir.

select soyadi, SUBSTRING(SoyAdi,2,3) from dbo.Personeller

-- LTRIM :Soldan boÅŸluklarÄ± keser.

select '       OÄŸuzhan'
select LTRIM('     OÄŸuzhan')

--- RTRIM : SaÄŸdaki boÅŸluklarÄ± keser.

select RTRIM('Zehra     ')

--- REVERSE :Tersine Ã§evirir.

select REVERSE(Adi) from dbo.Personeller

--- REPLACE :Belirtilen ifadeyi, belirtilen ifade ile deÄŸiÅŸtirir.

select REPLACE('Merhaba ben OÄŸuzhan','OÄŸuzhan','Zehra') 

--CHARINDEX :Belirtilen karakterin veri iÃ§inde sÄ±ra numarasÄ±nÄ± verir.

select MusteriAdi, CHARINDEX('r',MusteriAdi) from dbo.Musteriler

-- CHARINDEX ornek
--- MÃ¼ÅŸteriler tablosunun MusteriAdi kolonundan sadece adlarÄ±nÄ± Ã§ekelim.

select MusteriAdi, SUBSTRING(MusteriAdi,0,CHARINDEX(' ',MusteriAdi)) [Ä°lk AdÄ±] from dbo.Musteriler

--- MÃ¼ÅŸteriler- tablosunun Musterâ€¢iAdi kolonundan sadece soyadlarÄ±nÄ± Ã§ekelim.

select MusteriAdi
,SUBSTRING(MusteriAdi
,CHARINDEX(' ',MusteriAdi)
,LEN(MusteriAdi)-(charindex(' ',MusteriAdi)-1)) 
from dbo.Musteriler





-- SAYÄ±SAL DEÄER Ä°ÅLEMLERI

select 3 + 2
select 4-2
select 5*2 
select 10/2

--Pi sayÄ±sÄ±nÄ± verir.
select PI()

--- SIN : SinÃ¼s alÄ±r.
select SIN(90)

-- POWER :Ãœs alÄ±r.
select power(2,3)

-- ABS : Mutlak deÄŸer alÄ±r.
select abs(-12)

--RAND: 0 - 1 arasÄ±nda rastgele sayÄ± Ã¼retir.
Select RAND()

-- FLOOR :Yuvarlama yapar.
select FLOOR(rand()*100)



-- Tarih FonksiyonlarÄ±
--- GETDATE :Bu gÃ¼nÃ¼n tarihini verir.

select GETDATE()

-- DATEADD :Verilen tarihe verildiÄŸi kadar gÃ¼n, ay, yÄ±l ekler.

select DATEADD(day,999,getdate())

select DATEADD(month,99,getdate())

select DATEADD(year,9,'5.5.2009')

-- DATEDIFF : Ä°ki tarih arasÄ±nda gÃ¼nÃ¼, ayÄ± veya yÄ±lÄ± hesaplar.

select DATEDIFF(day,'01.01.2025',getdate())
select DATEDIFF(day,'06.29.2015',getdate())

select DATEDIFF(month,'08.14.2021',getdate())

select DATEDIFF(year,'02.02.2024',GETDATE())

--- DATEPART :Verilen tarihin haftanÄ±n, ayÄ±n yahut yÄ±lÄ±n kaÃ§Ä±ncÄ± gÃ¼nÃ¼ olduÄŸunu hesaplar.

select DATEPART(DW,GETDATE()) --DW: Weekday

select DATEPART(month,getdate())

select DATEPART(day,getdate())

select DATEPART(year,getdate())




Use Northwind

--Top Komutu

select TOP 5 * from Personeller


--Distinct Komutu

select Sehir from Personeller

select DISTINCT Sehir from Personeller


--Group By Komutu

--Formulize edecek olursak: Normal kolon yanÄ±nda Aggregate fonksiyon Ã§aÄŸrÄ±lÄ±yorsa normal kolon Group By ile gruplanÄ±r

select PersonelID, count(*) [YaptÄ±ÄŸÄ± SatÄ±ÅŸ] from Satislar  GROUP BY PersonelID

select KategoriID,count(*) from Urunler group by KategoriID

select KategoriID,TedarikciID, count(*) from Urunler group by KategoriID,TedarikciID  --Birden fazla kolonu gruplama Ã¶rneÄŸi

select * from Urunler

select * from Satislar

select PersonelID,SUM(NakliyeUcreti) [Toplam Nakilye Ucreti] from Satislar group by PersonelID

--- Group By iÅŸleminde Where ÅartÄ± Kullanma

select PersonelID, count(*) from Satislar where PersonelID>5 group by PersonelID

select * from Urunler

select UrunAdi, BirimFiyati, count(*) [50 TL ve Uzeri] from Urunler where BirimFiyati>=50 group by UrunAdi,BirimFiyati

---Group By Ä°ÅŸleminde Having Komutu Kullanarak ÅŸart oluÅŸturma
--Not: Where komutu ile arasÄ±ndaki fark: Having aggregate fonksiyon iÃ§in ÅŸart gerekirse yazÄ±lÄ±r ve groupby komutundan sonra gelir.

select PersonelID, count(*) [Toplam KayÄ±t] from Satislar where PersonelID>5 group by PersonelID having count(*)>70




-- TablolarÄ± Yan Yana BirleÅŸtitme

Select * from Personeller
select * from Satislar

select * from Personeller, Satislar

select p.PersonelID, s.MusteriID from Personeller p , Satislar s

select p.PersonelID,s.PersonelID, count(*) [Toplam KayÄ±t] from Personeller p,Satislar s where p.PersonelID=s.PersonelID group by p.PersonelID,s.PersonelID

--YukarÄ±daki birleÅŸtirme Ã¶rneÄŸi ilkel bir yapÄ±dadÄ±r. aÅŸaÄŸÄ±da Joinleri bu yapÄ±yÄ± baz alarak iÅŸleyip  avantajlarÄ± veya dezavantajlarÄ±nÄ± inceleyeceÄŸiz




--- Inner Join veya Join
--- Genel MantÄ±k
--- Select * from Tablo1 Inner Join Tab1o2 on Tablo1.IliskiliKolon=Tablo2.IliskiliKolon
--- Tablolara alias tanÄ±mlanabilir.
--- Select * from Tablo1 t1 Inner Join Tablo2 t2 on t1.IliskiliKolon=t2.IliskiilKolon
--- Ä°ki Tabloyu Ä°liÅŸkisel BirleÅŸtirme
USE Northwind

--- Hangi personel hangi satÄ±ÅŸlarÄ± yapmÄ±ÅŸtÄ±r.(Personeller,Satislar)

select * from Personeller
select * from Satislar

select p.Adi+' '+p.SoyAdi [AdÄ± SoyadÄ±], s.SevkAdi from Personeller p inner join Satislar s on p.PersonelID=s.PersonelID 

--Hangi Ã¼rÃ¼n hangi kategoride. (Urunler, Kategoriler)

select u.UrunAdi, k.KategoriAdi from Urunler u inner join Kategoriler k on u.UrunID=k.KategoriID


--Inner Join'de Where Komutunun KullanÄ±mÄ±

--Beverages kategorisindeki Ã¼rÃ¼nlerim. (Urunler, Kategoriler)

select * from Urunler u inner join Kategoriler k on u.UrunID=k.KategoriID where k.KategoriAdi='Beverages'

--Beverages kategorisindeki Ã¼rÃ¼nlerimin sayÄ±sÄ± kaÃ§tÄ±r. (Urunler, Kategoriler)

select count(u.UrunAdi) KayÄ±t from Urunler u inner join Kategoriler k on u.UrunID=k.KategoriID where k.KategoriAdi='Beverages'

--Seafood kategorisindeki Ã¼rÃ¼nlerin listesi (Urunler, Kategoriler)

select u.UrunAdi Urunler from Urunler u inner join Kategoriler k on u.UrunID=u.KategoriID where k.KategoriAdi='Seafood'

--Hangi satÄ±ÅŸÄ± hangi Ã§alÄ±ÅŸanÄ±m yapmÄ±ÅŸ? (Satislar, Personeller)

select p.Adi+' '+p.SoyAdi [AdÄ± SoyadÄ±], s.SevkAdi from Satislar s inner join Personeller p  on s.PersonelID=p.PersonelID 

--Faks numarasÄ± 'nullâ€ olmayan tedarikcilerden alÄ±nmÄ±ÅŸ Ã¼rÃ¼nler nelerdir? (Urunler,Tedarikciler)

select u.UrunAdi,t.Faks from Urunler u inner join Tedarikciler t on u.TedarikciID=t.TedarikciID where t.Faks<>'Null'

select u.UrunAdi,t.Faks from Urunler u inner join Tedarikciler t on u.TedarikciID=t.TedarikciID where t.Faks is not null




-- - Ä°kiden Fazla Tabloyu Ä°liÅŸkisel BirleÅŸtirme
--- 1997 yÄ±lÄ±ndan sonra Nancy nin satÄ±ÅŸ yaptÄ±ÄŸÄ± firmalarÄ±n isimleri: (1997 dahil)(MÃ¼ÅŸteriler, Satislar, Personeller)

select p.Adi, m.SirketAdi from Personeller p inner join Satislar s on p.PersonelID=s.PersonelID inner join Musteriler m on m.MusteriID=s.MusteriID where p.Adi='Nancy' and  Year(s.SatisTarihi)>=1997

-- Limited olan tedarikÃ§ilerden alÄ±nmÄ±ÅŸ seafood kategorisindeki Ã¼rÃ¼nlerimin toplam satÄ±ÅŸ tutarÄ±. (Urunler , Kategoriler, Tedarikciler)

select Sum(u.BirimFiyati * u.HedefStokDuzeyi) [Toplam SatÄ±ÅŸ TutarÄ±] from Kategoriler k inner join Urunler u on k.KategoriID=u.KategoriID inner join Tedarikciler t on t.TedarikciID=u.TedarikciID where k.KategoriAdi='Seafood' and t.SirketAdi Like '%Ltd.%'



-- - AynÄ± Tabloyu Ä°liÅŸkisel Olarak BirleÅŸtirme

-- Personellerimin baÄŸlÄ± olarak Ã§alÄ±ÅŸtÄ±ÄŸÄ± kiÅŸileri listele? (Personeller, Personeller)

select ast.Adi Ast, ust.Adi Ust from Personeller ust inner join Personeller ast on ust.PersonelID=ast.BagliCalistigiKisi


-- Inner Joinde Grup By

use Northwind
-- Hangi personelim(adl ve soyadÄ± Ä°le birlikte), toplam kaÃ§ adetlik satÄ±ÅŸ yapmÄ±ÅŸ. SatÄ±ÅŸ adedi 100 den fazla olanlar ve personelin adÄ±nÄ±n baÅŸ harfi M olan kayÄ±tlar gelsin. (Personeller, Satislar)

select p.Adi+' '+p.SoyAdi [AdÄ±SoyadÄ±], count(s.SatisID) from Personeller p inner join Satislar s on p.PersonelID=s.PersonelID  where p.Adi like 'M%' group by p.Adi+' '+p.SoyAdi having COUNT(s.SatisID)>100 

--- Seafood kategorisindeki Ã¼rÃ¼nlerin sayÄ±sÄ±? (Urunler, Kategoriler)

select k.KategoriAdi, count(*) KayitSayisi from Kategoriler k inner join Urunler u on k.KategoriID=u.KategoriID where k.KategoriAdi='Seafood' group by k.KategoriAdi

-- Hangi personelim toplam kaÃ§ adet satÄ±ÅŸ yapmÄ±ÅŸ? (Personeller, Sati51ar)

select p.Adi+' '+p.SoyAdi [AdÄ± SoyadÄ±], count(*) [SattÄ±ÄŸÄ± Urun Adeti] from Personeller p inner join Satislar s on p.PersonelID=s.PersonelID group by p.Adi+' '+p.SoyAdi

--- En Ã§ok satÄ±ÅŸ yapan personelim? (Personeller, Satislar)
select top 1 p.Adi, COUNT(*) from Personeller p inner join Satislar s on p.PersonelID=s.PersonelID group by p.Adi order by COUNT(*) desc

--- AdÄ±nda "aâ€ harfi olan personellerin satÄ±ÅŸ id si 10500 den bÃ¼yÃ¼k olan satÄ±ÅŸlarÄ±nÄ±n toplam tutarÄ±nÄ±(miktar*birimfiyat) ve bu satÄ±ÅŸlarÄ±n hangi tarihte gerÃ§ekleÅŸtiÄŸini listele. (Personeller, Satislar, [SatÄ°s Detaylari)

 select convert(nvarchar,day(s.SatisTarihi)) + '.' + convert(nvarchar,month(s.Satistarihi)) + '.' + convert(nvarchar,year(s.Satistarihi)) [SatÄ±ÅŸ Tarihi], SUM(d.Miktar*d.BirimFiyati) [toplam SatÄ±ÅŸ TutarÄ±] from Personeller p inner join Satislar s on p.PersonelID=s.PersonelID inner join [Satis Detaylari] d on s.SatisID=d.SatisID where p.Adi like '%a%' and s.SatisID>10500 group by s.SatisTarihi order by s.SatisTarihi asc




--Outer Join(Left,Right,Full) ile TablolarÄ± BirleÅŸtirme 

use OrnekVT
INSERT INTO Filmler (Filmid, FilmAdi) VALUES
(1, 'GORA'),
(2, 'Lord Of The Rings'),
(3, 'DÃ¼ÄŸÃ¼n Dernek'),
(4, 'Bir Zamanlar Anadolu''da'),
(5, 'Kurtlar Vadisi'),
(6, 'Recep Ä°vedik'),
(7, 'DÃ¼ÄŸÃ¼n Dernek'),
(8, 'Kahpe Bizans');

select * from Filmler

INSERT INTO Oyuncular (OyuncuId, Filmid, Adi, Soyadi) VALUES
(1, 1, 'Cem', 'YÄ±lmaz'),
(2, 2, 'Muiddin', 'Ä°mpatrino'),
(4, 2, 'Turgay', 'Arslaner'),
(5, 3, 'GÃ¶khan', 'AÅŸker'),
(6, 4, 'Mustafa', 'AÄŸaoÄŸlu'),
(7, 4, 'Mustafa', 'GÃ¼loÄŸlu'),
(8, 5, 'Mustafa', 'NuroÄŸlu'),
(9, 5, 'M ust4', 'BilmemneoÄŸlu');

select * from Oyuncular


-- Inner Jcin'de eÅŸleÅŸen kayÄ±tlar getiriliyordu. Outer Join 'de ise eÅŸleÅŸmeyen kayÄ±tlarda getirilmektedir.


-- Left Join
-- Join ifadesinin solundaki tablodan tÃ¼m kayÄ±tlarÄ± getirir. SaÄŸÄ±ndaki tablodan eÅŸleÅŸenleri yan yana eÅŸleÅŸmeyenleri null olarak getirir.

select * from Filmler f left outer join Oyuncular o on f.FilmId=o.FilmID
select * from Oyuncular o left outer join Filmler f on o.FilmID=f.FilmId

-- veya

select * from Oyuncular o left join Filmler f on o.FilmID=f.FilmId
select *from Filmler f left join Oyuncular o on f.FilmId=o.FilmID

--Not : outer keyword'Ã¼ eskiden kullanÄ±lÄ±yordu. GÃ¼ncel olarak kullanÄ±lmasÄ±na gerek yok dolayÄ±syla aÅŸaÄŸÄ±daki komutlarda outer keyword'Ã¼ yazÄ±lmayacak.

--- Right Join
-- Joinin saÄŸÄ±ndaki tablonun tamamÄ±nÄ± getirecek, solundakinden eÅŸleÅŸenleri aynÄ± satÄ±rda eÅŸleÅŸmeyenleri de null olarak getirecek.

select * from Oyuncular o right join Filmler f on o.FilmID=f.FilmId
select* from Filmler f right join  Oyuncular o on o.FilmID=f.FilmId


-- Full Join
--- Joinin iki tarafÄ±ndaki tablolardan eÅŸleÅŸen eÅŸleÅŸmeyen hepsini getirir.
select * from Oyuncular o full join Filmler f on o.FilmID=f.FilmId

select * from Filmler f full join Oyuncular o on o.FilmID=f.FilmId





--Cross Join 
-- Cross Join iki tablo arasÄ±nda kartezyen Ã§arpÄ±m saÄŸlar ve sonucu tablo olarqak dÃ¶ndÃ¼rÃ¼r.
--AÅŸaÄŸÄ±daki Ã¶rnekte iki farklÄ± tabloyu cross join ile birleÅŸtireceÄŸiz. DoÄŸru birleÅŸmenin saÄŸlamasÄ±nÄ± iki tablonun eleman saysÄ±nÄ±n Ã§arpÄ±mÄ± ile doÄŸrulancakatÄ±r. Ã–rnek: Personeller Count = 9 BÃ¶lge Count =4 9*4=36 adet sonuÃ§ dÃ¶ndÃ¼rmesi gerekiyor.
use Northwind
select count(*) from Personeller 
select count(*) from Bolge

select p.Adi,b.BolgeID from Personeller p cross join Bolge b

--Not:
--1) DiÄŸer Join komutlarÄ±nda olduÄŸu gibi ON keyword'Ã¼nÃ¼ kullanmayÄ±z. Ã‡Ã¼nkÃ¼ kartezyen Ã§arpÄ±m ile bÃ¼tÃ¼n eÅŸleÅŸmeleri yapÄ±yor.
--2) Where keyword2Ã¼ ile herhangi bir ÅŸartta baÄŸlanamaz.

--Ã–rnek :
--10 Ã¶ÄŸrenci adayÄ± var âœ…

--9 farklÄ± temin tipi var âœ…

--Her Ã¶ÄŸrenci adayÄ± her temin tipini seÃ§ebilir (tÃ¼m kombinasyonlar gerekir) âœ…

--Yani:

--Her Ã¶ÄŸrenci 9 temin tipinden birini seÃ§ebileceÄŸi gibi hepsiyle eÅŸleÅŸmesi de ihtimal dahilinde.
--SonuÃ§: 10 Ã— 9 = 90 satÄ±r




-----DML KOMUTLARINA GÄ°RÄ°Å----

--DML (Data Manipulation Language)
---- Select, insert, Update, Delete
--- Select...
--- insert ...
--- Update ...
--- Delete ...

USE Northwind

--Select 
Select * from Personeller


--Insert 
-- Insert [Tablo AdÄ±] (Kolonlar) Values(DeÄŸerler)

--Kolon adÄ± belirterek ekleme
insert  Personeller(Adi,SoyAdi) values('OÄŸuzhan','Dilek') --Kolon adlarÄ± ile gÃ¶ndereceÄŸiniz values'ler aynÄ± Ä±rada olamalÄ±dÄ±r.

--TÃ¼m Kolonlara veri ekleme

insert Personeller values('Dilek','Zehra','TatlÄ± Bebek','Immm','01.01.2024',GETDATE(),'Ankara','Erzurum','Ä°Ã§Anadolu','0600','Turkiye',null,null,null,null,null,null)


--- [Dikkat Edilmesi Gerekenler! ! ! ]
--- Into Komutu Ä°le YazÄ±labilir
insert into Personeller(SoyAdi,Adi) values('Dilek','SutlaÃ§')
--- Kolonun kabul ettiÄŸi veri tipi ve karakter uzunluÄŸunda kayÄ±t yapÄ±lmalÄ±dÄ±r.
--- Not NuII olan kolonlara boÅŸ bÄ±rakÄ±lamayacaklarÄ±ndan dolayÄ± mutlaka deÄŸer gÃ¶nderilmelidir.
insert Personeller(Unvan,UnvanEki) values ('Doktor','Prof.')

-- Otomatik artan(Ä°dentÄ°ty) kolonlara deÄŸer gÃ¶nderilmez.
-- Tablodaki seÃ§ilen yahut bÃ¼tÃ¼n kolonlara deÄŸer gÃ¶nderileceÄŸi belirtilip, gÃ¶nderilmezse hata verecektir.

insert Personeller(Adi,SoyAdi) values('Dilek')
insert Personeller values('Dilek')

---[Pratik KullanÄ±m]
insert Personeller(Adi,Soyadi) values ('Sulhettin','Kebap')
insert Personeller(Adi,Soyadi) values ('Murtaza','Yanbakan')
insert Personeller(Adi,Soyadi) values ('MugÄ±me','DÃ¼zayak')

insert Personeller(Adi,SoyAdi) values ('Sulhettin','Kebap'),
	('Murtaza','Yanbakan'),
	('MugÄ±me','DÃ¼zayak')
	
	
	
--- [insert Komutu Ä°le Select Sorgusu Sonucu Gelen Verileri FarklÄ± Tabloya Kaydetme]
select * from OrnekPersoneller
insert OrnekPersoneller select Adi,Soyadi from Personeller
-- Burada dikkat etmeniz gereken nokta; Select sorgusunda donen kolon sayÄ±sÄ± Ä°le insert Ä°ÅŸlemi yapÄ±lacak tablonun;
-- 1) kolon sayÄ±sÄ± birbirine eÅŸit olmasÄ± 
-- 2) tiplerinin aynÄ± olmasÄ±
-- 3) Kolon SÄ±rasÄ±nÄ±n aynÄ± olmasÄ± gerekmektedir.
-- 4) Kolon isimlerinin dahi aynÄ± olamsÄ± lazÄ±m


-- [Select Sorgusu Sonucu Gelen Verileri FarklÄ± Bir Tablo OluÅŸturarak Kaydetme]
 select Adi,Soyadi,Ulke into OrnekPersoneller2 from Personeller
 select * from OrnekPersoneller2
--- Bu yÃ¶ntemle primary key ve foreign keyler oluÅŸturulamazlar.



--- Update
--- Update [Tablo AdÄ±] Set [Kolon AdÄ±] = DeÄŸer

use Northwind

update OrnekPersoneller set Adi='ÃœlkÃ¼' where Adi='Zehra' --EÄŸer where ÅŸartÄ± konulmazsa bÃ¼tÃ¼n kolunun hepsini set edilen deÄŸer ile gÃ¼nceller
select * from OrnekPersoneller

--- [Update Sorgusunda Join YapÄ±larÄ±nÄ± Kullanarak Birden Fazla Tabloda GÃ¼ncelleme Yapmak]
select * from OrnekPersoneller
--Personeller tablsounda 12 ID'li personelin soyadÄ±nÄ±  OrnekPersoneller tablsonudaki AdÄ± kolnuyla gÃ¼ncelle
update OrnekPersoneller set Adi= p.SoyAdi from Personeller p inner join OrnekPersoneller o on p.PersonelID=o.PersonelId where p.PersonelID=12

--- [Update Sorgusunda Subquery Ä°le GÃ¼ncelleme Yapmak)

Update OrnekPersoneller set Soyadi=(Select Adi from Personeller where PersonelID=3) where OrnekPersoneller.Adi='Janet'

--- [Update Sorgusunda Top KeywordÃ¼ Ä°le GÃ¼ncelleme Yapmak]

update top (3) OrnekPersoneller set SoyAdi=null


--- Delete
--- Delete from [Tablo AdÄ± ]

--[Delete Sorgusuna Where Åartl Yazmak]


Delete From OrnekPersoneller where PersonelId<=3
select * from OrnekPersoneller
--- [Dikkat Edilmesi Gerekenler! ! ! ]
-- Delete sorgusuyla tablo iÃ§erisindeki tÃ¼m verileri silmeniz identity kolonunu sÄ±frlamayacaktÄ±r. Silme iÅŸleminden sonra Ä°lk eklenen veride kalÄ±ndÄ±ÄŸÄ± yerden id deÄŸeri verilecektir.
delete from OrnekPersoneller where Adi in ('Zehra')



-- Union | UnÄ°on All
--- Union Komutu
--- Birden fazla select sorgusu sonucunu tek seferde alt alta gÃ¶stermemizi saÄŸlar.

---AiaÅŸÄ±daki senaryoda Musteriler tablosundaki ad soyadlarÄ± alÄ±p SÄ±nÄ±fA , Personeller Tablosundaki  ad soyadlarÄ± alÄ±p SÄ±nÄ±fB TablolarÄ± oluÅŸturlacak ve bunlarÄ± Union ile birleÅŸtirip alt alat sÄ±ralama yapacaÄŸÄ±z. bu ÅŸeilde Okuladki tÃ¼m Ã¶ÄŸrenci listesi Ã§Ä±kmÄ±ÅŸ olacak

select SUBSTRING(MusteriAdi,0,CHARINDEX(' ',MusteriAdi)) [Adi],SUBSTRING(MusteriAdi,CHARINDEX(' ',MusteriAdi),LEN(MusteriAdi)-(charindex(' ',MusteriAdi)-1))[SoyAdi]  into SinifB from Musteriler

select PersonelID,SoyAdi,Adi into SinifA from Personeller


Select  Adi,SoyAdi from SinifA
Union
Select Adi,SoyAdi from SinifB

--- 2 'den fazla
Select  Adi,SoyAdi from SinifA
Union
Select Adi,SoyAdi from SinifB
Union
Select Adi,SoyAdi from Personeller

--Joinler yan yana, Union alt alta tablolarÄ± birleÅŸtirir. Joinlerde belirli(iliÅŸkisel) bir kolon Ã¼zerinden birleÅŸtirme yapÄ±lÄ±rken, Union 'da bÃ¶yle bir durum yoktur.

--- Dikkat etmemiz gereken koÅŸullar;
-- Union sorgusunun sonucunda oluÅŸan tablonun kolon isimleri, Ã¼stteki sorgunun kolon Ä°simlerinden oluÅŸturulur.
--- Ãœstteki sorgudan kaÃ§ kolon Ã§ekilmiÅŸse alttaki sorgudan da o kadar Ã§ekilmek zorundadÄ±r.
-- Ãœstteki sorgudan Ã§ekilen kolonlarÄ±n tipleriyle, alttaki sorgudan Ã§ekilen kolonlarÄ±n tipleri uyumlu olmalÄ±dÄ±r.
--- Union tekrarlÄ± kayÄ±tlarÄ± getirmez.
-- Union'da kullanÄ±lan tablolara kolon eklenebilir. Dikkat etmemiz gereken nokta, yukarÄ±daki kurallar Ã§erÃ§evesinde aÅŸaÄŸÄ±yada yukarÄ±yada aynÄ± sayÄ±da kolonlarÄ±n eklenmesi gerekmektedir.


Select  Adi,SoyAdi,'A SÄ±nÄ±fÄ±' from SinifA
Union
Select Adi,SoyAdi,'B SÄ±nÄ±fÄ±' from SinifB

-- Union ALL
--- Union tekrarlÄ± kayÄ±tlarÄ± getirmez. TekrarlÄ± kayÄ±tlarÄ± getirmek iÃ§in Union All Komutu kullanÄ±lmalÄ±dÄ±r.

Select  Adi,SoyAdi from SinifA
Union All
Select Adi,SoyAdi from SinifA




-- With Rollup | Wtith Cube

-- With Rollup Group By ile gruplanmÄ±ÅŸ veri kÃ¼mesinde ara toplam alÄ±nmasÄ±nÄ± saÄŸlar.

Select Sehir,Urun,Sum(SatisMiktari) from Satislar group by Sehir,Urun with rollup
 --Sadece ÅŸehir bazlÄ± toplamlar + genel toplam var.

 --- [Having ÅartÄ±yla Beraber With Rollup]
 Select Sehir,Urun,Sum(SatisMiktari) from Satislar group by Sehir,Urun with rollup having sum(SatisMiktari)>10
 
 
 --With Cube TÃ¼m gruplarÄ±n tÃ¼m olasÄ± kombinasyonlarÄ±nÄ±n toplamlarÄ±nÄ± verir.

 Select Sehir,Urun,Sum(SatisMiktari) from Satislar group by Sehir,Urun with cube
 --ğŸ‘‰ Hem ÅŸehir hem Ã¼rÃ¼n bazlÄ± toplamlar + genel toplam var.

  --- [Having ÅartÄ±yla Beraber With Cube]
 Select Sehir,Urun,Sum(SatisMiktari) from Satislar group by Sehir,Urun with cube having sum(SatisMiktari)>10



-- Case - When- Else â€” End
-- Personellerimizin isim ve soyisimlerinin yanÄ±nda; UnvanEki 'Mr'Ä°se  Erkek, 'Ms.' ve'Mrs.' ise KadÄ±n  yazsÄ±n.

select Adi,SoyAdi,
Case
When UnvanEki='Mrs.' or Unvaneki='Ms.' Then 'KadÄ±n'
When UnvanEki='Mr.' Then 'Erkek'
Else UnvanEki
End
from Personeller

--- EÄŸer Ã¼rÃ¼nÃ¼n birim fiyatÄ± 0-50 arasÄ± Ä°se 'Ã‡in MalÄ±',	50 -100 arasÄ± Ä°se 'Ucuz',	100-200 arasÄ± Ä°se 'Normal' ve 200' den fazla Ä°se 'PahalÄ±' yazsÄ±n.

select UrunAdi,
Case
When BirimFiyati>0 and BirimFiyati<50 Then 'Ã‡in MalÄ±'
When BirimFiyati between 50 and 100 Then 'Ucuz'
When BirimFiyati between 100 and 200 Then 'Normal'
When BirimFiyati>200 Then 'PahalÄ±'
Else 'Belirsiz'
End
from Urunler

--YukarÄ±daki Ã¶rnekte bir filtre yapmak istersek o zamanda SubQuery yÃ¶nremini kullanÄ±rdÄ±k Yani;

select * from (select UrunAdi,
Case
When BirimFiyati>0 and BirimFiyati<50 Then 'Ã‡in MalÄ±'
When BirimFiyati between 50 and 100 Then 'Ucuz'
When BirimFiyati between 100 and 200 Then 'Normal'
When BirimFiyati>200 Then 'PahalÄ±'
Else 'Belirsiz'
End as FiyatGrubu
from Urunler) as UrunEtiketli
where FiyatGrubu='Ã‡in MalÄ±'


--With Ties Komutu
-- Bu komut TOP komutu ile birlikte kullananÄ±labilir. amacÄ± Belli sayÄ±da bir sÄ±ralama yaparken Ã¶rneÄŸin  ilk 6 kaydÄ± getirmek istediÄŸimizde 6. kayÄ±ta eÅŸ deÄŸer bir veri varsa onlarÄ± getirmeyi saÄŸlar. Mesala bir yarÄ±ÅŸmada ilk 3 kiÅŸi belirleriz ancak 3. kiÅŸi ilede aynÄ± puanÄ± almÄ±ÅŸ yarÄ±ÅŸmacÄ±lar olabilir. Ä°ÅŸte bÃ¶yle bir istisna durumda with ties komuut bize yardÄ±mcÄ± olacaktÄ±r.

--With Ties komutu kullanÄ±yorsan sorgunun sonunda ORDER BY'da kullanmak zorundasÄ±n

Select * from [Satis Detaylari]

select top 6 with ties * from [Satis Detaylari] order by SatisID

 
--With Komutu

-- WITH komutu (CTE - Common Table Expression),
-- karmaÅŸÄ±k sorgularÄ± daha okunabilir hale getirmek iÃ§in kullanÄ±lÄ±r.
-- GeÃ§ici bir sonuÃ§ kÃ¼mesi oluÅŸturur ve bu kÃ¼me, sorgunun devamÄ±nda sanki bir tablo gibi davranÄ±r.
-- Tek bir kez tanÄ±mlanÄ±r ve birden fazla kez kullanÄ±labilir (sorgu iÃ§inde).
-- Alt sorgulara gÃ¶re daha temiz ve modÃ¼ler bir yapÄ± sunar.


With PersonelSatis(id,adi,soyadi,satisId)
as 
(
select p.PersonelID,p.Adi,p.SoyAdi,s.SatisID from Personeller p inner join Satislar s on p.PersonelID=s.PersonelID
)

--select * from PersonelSatis

select * from PersonelSatis ps inner join [Satis Detaylari] sd on ps.satisId=sd.SatisID


--- Subquery (iÃ§ iÃ§e Sorgular)
-- Ã–nemli UyarÄ±: Subquery'ile dÃ¶nen verinin tek satÄ±rda olamsÄ± gerekmektedir eÄŸer birden fazla satÄ±r dÃ¶nerse subquey Ã§alÄ±ÅŸmayacaktÄ±r.

select s.SatisTarihi,s.SatisID from Personeller p inner join Satislar s on p.PersonelID=s.PersonelID where p.Adi='Nancy'
 
 select s.SatisTarihi,s.SatisID from Satislar s where s.PersonelID=(select p.PersonelID  from Personeller p where p.Adi='Nancy')
 
 
 
 --- Bulk insert
 
 --Kisiler.txt
 -- Ad	Soyad	Unvan
-- OÄŸuzhan	Dilek	Full Stack Dev.
-- Zehra	Dilek	BebiÅŸ
-- SÃ¼tlaÃ§	Dilek	PiÅŸo

bulk insert Kisiler from 'D:\personal-repo\T-SQL-DERSLER-\Kisiler.txt'
with
(
Fieldterminator='\t',
RowTerminator='\n'
)

select * from Kisiler


--Truncate Komutu

--__Identity kolonunu sÄ±fÄ±rlar
--Test yapÄ±ldÄ±ktan sonra proje Publish edilemeden Ã¶nce test verilerini sÄ±fÄ±rlamak iÃ§in kullanÄ±labilir.

select * into PersonellerX from Personeller

truncate table PersonellerX


--@@Identity Komuutu

--Son yapÄ±lan Insert iÅŸleminin Identity deÄŸerini bir tabloda getirir

Insert into Kategoriler(KategoriAdi,Tanimi) values ('X','X Kategorisi')

select @@IDENTITY

Insert Personeller(Adi,SoyAdi) values('Husam','Candar')

--@@ROWCOUNT Komutu

--Herhangi bir iÅŸlemde (Select, Insert, Update vs) etkilenen kaÃ§ deÄŸer varsa onu dÃ¶ndÃ¼rÃ¼r

Delete from PersonellerX where Adi='Husam'
Select @@ROWCOUNT

Select * from Personeller
select @@ROWCOUNT

Insert PersonellerX(Adi,Soyadi) Values('Adam','Smith'),
										('Muhit','SS')
										select @@ROWCOUNT
										


--Identity Kolonuna MÃ¼dahale etme
--Ã–nmeli UyarÄ± Son Ä°dentity deÄŸerinde daha yÃ¼kesk bir deÄŸer girlmesi gerekir
DBCC Checkident(PersonellerX,reseed,27)




--NULL Kontrol MekanizmalarÄ±

-- Bu mekanizmalarÄ± null deÄŸerleri olan bir tabloda rapor hazÄ±rlarken kullanÄ±rÄ±z.

-- Case-Hhen-Then-E1se-End KalÄ±bÄ± Ä°le Null KontrolÃ¼

Select MusteriAdi, Bolge, 
Case
When Bolge IS NULL then 'BÃ¶lge Bilinmiyor'
else
Bolge
End
 from Musteriler

 ---- Coalesce Fonksiyonu Ä°le Null KontrolÃ¼

 select MusteriAdi, coalesce(Bolge,'BÃ¶lge Bilinmiyor')  from Musteriler
--Null KontrolÃ¼ yapÄ±lcak olan kolonun tipi ne ise ikinci parametrede o itpte olmalÄ±dÄ±r.

 -- IsNull Fonksiyonu Ä°le Null KontrolÃ¼

 select MusteriAdi, isnull(Bolge,'Bolge Bilinmiyor') from Musteriler
 --Null KontrolÃ¼ yapÄ±lcak olan kolonun tipi ne ise ikinci parametrede o itpte olmalÄ±dÄ±r.

 -- NullIf Fonksiyonu Ä°le Null KontrolÃ¼
-- Fonksiyona verilen kolon, Ä°kinci parametre verilen deÄŸere eÅŸit Ä°se o kolonu Null olarak getirir.

select nullif(1,2);
select nullif(0,0);

Select HedefStokDuzeyi from Urunler
Select AVG(HedefStokDuzeyi) from Urunler

--- Hedef stok dÃ¼zeyi O olmayan Ã¼rÃ¼nlerin ortalamasÄ± nedir?
Select AVG(HedefStokDuzeyi) from Urunler where HedefStokDuzeyi<>0
select AVG(nullif(HedefStokDuzeyi,0)) from Urunler 

--ONEMLÄ° RAPORLARDA KESÄ°NÄ°LKLE NULL DEÄERLERÄ° BOÅ BIRAKMAYIN!!'NULLIFF ile veya diÄŸer fonksiyonlarla bir ÅŸekilde belli edin yada hesaptan Ã§Ä±karÄ±lamsÄ±nÄ± saÄŸlayÄ±n. Aksi halde yanlÄ±ÅŸ hesap Ã§arÅŸÄ±dan dÃ¶ner


--- T -SQL ile VeritabanÄ±ndaki TablolarÄ± Listeleme

select * from sys.tables

--ya da

Select * from sysobjects where xtype='u'


--- Bir Tablonun Primary Key Olup OlmadÄ±ÄŸÄ±nÄ± Kontrol Etme

Select OBJECTPROPERTY(OBJECT_ID('Personeller'),'TableHasPrimaryKey')

-- EÄŸer sonuÃ§ 1 deÄŸerini dÃ¶ndÃ¼rÃ¼yrsa o zman tabloda primary key mevcuttur.








--DDl (Data Definition Language)
--- T-SQL de veritabanÄ± nesneleri oluÅŸturmamÄ±zÄ± saÄŸlayan ve bu nesneler Ã¼zerinde deÄŸiÅŸiklikler yapnamÄ±zÄ± ve silmenizi saÄŸlayan yapÄ±lar bu baÅŸlÄ±k altÄ±nda simgelenmektedir.
-- Create, Alter, Drop 

- ---CREATE---
-- VeritabanÄ± nesnesi oluÅŸturmamÄ±zÄ± saÄŸlar.(database,table,view,storedproc,trigger vs.)
-- Prototipi
--Create [Nesne] [Nesnenin Adi]
-- â€”Create Ä°le Database OluÅŸturma

Create Database OrnekVeriTabani

--- Bu ÅŸekilde bir kullanÄ±m varsayÄ±lan ayarlarda veritabanÄ± oluÅŸturacaktÄ±r.

Create Database OrnekVeriTabani
on
(
	Name='GG',
	Filename='D:\GG.mdf',
	Size=5,
	Filegrowth=3
)
-- Name : OluÅŸturulacak veritabanÄ±nÄ±n fiziksel ismini belirtiyoruz.
--- Filename : OluÅŸturulacak veritabanÄ± dosyasÄ±nÄ±n fiziksel dizinini belirtiyoruz.
--- Size : VeritabanÄ±nÄ±n baÅŸlangÄ±Ã§ boyutunu mb cinsinden ayarlÄ±yoruz.
--- Filegrowth : VeritabanÄ±nÄ±n boyutu, baÅŸlangÄ±Ã§ boyutunu geÃ§tiÄŸi durumda boyutun ne kadar artmasÄ± gerektiÄŸini mb cinsinden belirtiyoruz.


-- â€”Create Ä°le Log DosyasÄ±yla Birlikte Database OluÅŸturma

Create Database OrnekVeriTabani
on
(
	Name='GG',
	Filename='D:\GG.mdf',
	Size=5,
	Filegrowth=3
)
Log
on
(
	Name='GG_LOG',
	Filename='D:\GG.ldf',
	Size=5,
	Filegrowth=3
)

-- â€”Create Ä°le Tablo OluÅŸturma
USE OrnekVeriTabani

Create Table tablo1c
(
	Kolon1 int,
	Kolon2 nvarchar(max),
	Kolon3 money
)

--- EÄŸer kolon adlarÄ±nda boÅŸluk varsa kÃ¶ÅŸeli parantez ile belirtilmelidir.

Create table tablo2
(
	[Kolon 1] int,
	[Kolon 2] nvarchar(50),
	[Kolon 3] money
)

--- â€”Kolona Primary Key ve Identity Ã¶zelliÄŸi KazandÄ±rmak

create table Tablo3
(
	Id int Primary key Identity (1,1),
	Kolon2 nvarchar(20)
)



---ALTER-----
-- Create ile oluÅŸturulan veritabanÄ± nesnelerinde deÄŸiÅŸiklik yapmamÄ±zÄ± saÄŸlar.
-- Prototip
-- Alter [Nesne] [Nesnenin Adi]
-- (YapÄ±ya GÃ¶re Ä°ÅŸlemler)

-- â€”Alter Ä°le Database GÃ¼ncelleme

Alter Database OrnekVeriTabani
Modify File
(
	Name='GG', --Name' i GG olan veritabanÄ±na gÃ¶re iÅŸem ayapar aslÄ±nda burada bir where var
	Size=20
)

--- â€”Alter Ä°le Olan Bir- Tablo 8 Kolon Ekleme

Alter Table tablo1
Add Kolon5 nvarchar(max)


--- Alter- Ä°le Tablodaki Kolonu GÃ¼ncelleme
Alter table tablo1
Alter Column Kolon4 int
--Not kolonda veri olmamasÄ± gerkiyor

-- â€”Alter Ä°le Tablodaki Kolonu Silme
Alter Table tablo1
Drop Column Kolon4

-- â€”Alter Ä°le Tabloya Constraint Ekleme

Alter Table tablo1
Add Constraint OrnekConstraint Default 'boÅŸ' for Kolon2

-- â€”Alter Ä°le Tabloya Constraint Silme

Alter Table tablo1
Drop Constraint OrnekConstraint 



-- SP_RENAME ile tablo adÄ± GÃ¼ncelleme

SP_RENAME 'tablo1','OrnekTablo'


-- SP_RENAME ile Kolon adÄ±  GÃ¼ncelleme

SP_RENAME 'OrnekTablo.Kolon1','Id','Column'

-- Create Ä°le oluÅŸturulan veri tabanÄ± nesnelerini silmemize yarar.
-- Prototip
--- Drop [Nesne] [Nesne AdÄ±]
Drop table OrnekTablo
Drop Database OrnekVeriTabani





-- Constraintler (KÄ±sÄ±tlayÄ±cÄ±lar)
-- Constraintler sayesinde tablolar Ã¼zerinde istediÄŸimiz ÅŸartlar ve durumlara gÃ¶re kÄ±sÄ±tlamalar yapabiliyoruz.
--DEFAULT CONSTRAINT
--CHECK CONSTRAINT
--PRÄ°MARY KEY CONSTRAINT
--UNIQUE COUSTRAINT
--FOREIGN KEY CONSTRAINT 


--- DEFAULT CONSTRAINT
--- Default ConstraÄ°nt sayesinde kolona bir deÄŸer girilmediÄŸi taktirde varsayÄ±lan olarak ne girilmesi gerektiÄŸini belirtebiliyoruz.
---- Genel YapÄ±sÄ±;
--- Add Constraint [Constraint AdÄ± ] Default 'VarsayÄ±lan DeÄŸer' For [Kolon AdÄ±]

create table OrnekTablo
(
Id int primary key identity(1,1),
Kolon1 nvarchar(max),
Kolon2 int
)

Alter Table OrnekTablo
Add Constraint Kolon1Constraint Default 'Bilgi Yok' For Kolon1

Alter Table OrnekTablo
Add Constraint Kolon2Constraint Default -1 For Kolon2


insert OrnekTablo(Kolon2) values(0)
insert OrnekTablo(Kolon1) values('Ã–rnek bir deÄŸer')

select * from OrnekTablo


--CHECK CONSTRAÄ°NT
-- Bir kolona girilecek olan verinin belirli bir ÅŸarta uymasÄ±nÄ± zorunlu tutar.
--- Genel YapÄ±sÄ±;
-- Add Constraint [Constraint AdÄ±] Check (ÅART)

Alter table OrnekTablo
Add Constraint Kolon2Kontrol Check ((Kolon2*5)%2=0)

-- Check ccnstraint oluÅŸturulmadan Ã¶nce ilgili tabloda ÅŸarta aykÄ±rÄ± deÄŸerler varsa eÄŸer	constraint oluÅŸturulmayacaktÄ±r !
-- Ancak Ã¶nceki kayÄ±tlarÄ± gÃ¶rmezden gelip genede Check ConstraintÄ° uygulamak Ä°stiyorsak	"WÄ°th Nocheck" komutu kullanÄ±lmalÄ±dÄ±r.
-- WÄ°th Nocheck Komutu
--- Åuana kadar olan kayÄ±tlarÄ± gÃ¶rmezden gelip, check constrainti uygulattÄ±rÄ±r.

Alter table OrnekTablo
--Drop Constraint Kolon2Kontrol
With Nocheck Add Constraint Kolon2Kontrol Check ((Kolon2*5)%2=0)

---PRIMARY KEY CONSTRAINT
--- Primary Key Constraint ile; o kolona eklenen primary key ile, baÅŸka tablolarda foreign key oluÅŸturarak iliÅŸki kurmamÄ±z mÃ¼mkÃ¼n olur.
--Bunun yanÄ±nda o kolonun taÅŸÄ±dÄ±ÄŸÄ± verinin tekil olacaÄŸÄ± da garanti edilmiÅŸ olur. Primary key constraint Ä°le ayrÄ±ca CLUSTERED index oluÅŸturulmuÅŸ da olur.
---- Genel YapÄ±sÄ±;
--- Add Constraint [Constraint AdÄ±] Primary Key (Kolon AdÄ±)

--DÄ°KKAT!!!
-- Primary Key Constraint kullanÄ±lan kolon primary key Ã¶zelliÄŸine sahip olmamalÄ±dÄ±r.

Alter table Ornektablo
Add Constraint PrimaryId Primary key (Id)


-- UNIQUE CONSTRAINT
-- Unique constraintin tek amacÄ±, belirttiÄŸimiz kolondaki deÄŸerlerin tekil olmasÄ±nÄ± saÄŸlamaktÄ±r.
-- Genel YapÄ±sÄ±;
--- Add ConstraÄ°nt [ConstraÄ°nt AdÄ±] Unique (Kolon AdÄ±)

Alter table Ornektablo
Add Constraint OrnekTabloUnique Unique (Kolon2)
--"Kolon2" kolonuna unique constraint verilerek tekil hale getirilmiÅŸtir. Bundan sonra ikitane aynÄ± veriden kayÄ±t yapÄ±lamamaktadÄ±r.

--- FOREIGN KEY CONSTRAINT
-- TablolarÄ±n kolonlarÄ± arasÄ±nda iliÅŸki kurmamÄ±zÄ± saÄŸlar. Bu iliÅŸki neticesinde; foreign key olan kolondaki karÅŸÄ±lÄ±ÄŸÄ±nÄ±n boÅŸa dÃ¼ÅŸmemesi Ä°Ã§in primary key kolonu olan tablodan veri silinmesini, gÃ¼ncellenmesini engeller.
-- Genel YapÄ±sÄ±;
--- Add Constraint [Constraint AdÄ±] Foreign Key (Kolon AdÄ±) References [2. Tablo AdÄ±] (2. Tablodaki Kolon AdÄ±)


create table Ogrenciler
(
OgrenciId int primary key identity(1,10),
DersId int,
Adi nvarchar(50),
Soyadi nvarchar(50)
)
create table Dersler
(
DersId int primary key identity(1,1),
DersAdi nvarchar(50)
)

Alter table Ogrenciler
Add Constraint ForeignKeyOgrenciDers Foreign key (DersId) References Dersler(DersId)

--- Åu durumda, delete ve update Ä°ÅŸlemlerinden Ä°liÅŸkili kolondaki veriler etkilenmez.
-- DavranÄ±ÅŸÄ± deÄŸiÅŸtirmek iÃ§in aÅŸaÄŸÄ±daki komutlar kullanÄ±lÄ±r.

--- -Cascade
---- Ana tablodaki kayÄ±t silindiÄŸinde ya da gÃ¼ncellendiÄŸinde, Ä°liÅŸkili kolondaki karÅŸÄ±lÄ±ÄŸÄ±da otomatik olarak silinir ya da gÃ¼ncellenir.

Alter Table Ogrenciler
Add Constraint ForeingKeyOgrenciDers Foreign Key (DersId) References Dersler(DersId)
ON DELETE CASCADE
ON UPDATE CASCADE

--- â€”Set Null
---- Ana tablodaki kayÄ±t silindiÄŸinde ya da gÃ¼ncellendiÄŸinde, iliÅŸkili kolondaki karÅŸÄ±lÄ±ÄŸÄ±na "Null" deÄŸer basÄ±lÄ±r.
Alter table Ogrenciler
add Constraint ForeignKeyOgrenciDers  Foreign Key (DersId) References Dersler(DersId)
ON Delete Set Null
ON Update Set Null

--- -Set Default
---- Ana tablodaki kayÄ±t silindiÄŸinde ya da gÃ¼ncellendiÄŸinde, iliÅŸkili kolondaki karÅŸÄ±lÄ±ÄŸÄ±na o kolonun default deÄŸeri basÄ±lÄ±r. Bu default deÄŸer dediÄŸimiz default tipte bir constrainttir. Bunu kendimiz oluÅŸturabiliriz.

Alter Table Ogrenciler
Add Constraint SetDefaultConstraint Default -1 For DersId

Alter Table Ogrenciler
Add Constraint ForeignKeyOgrenciDers Foreign key (DersId) References Dersler(DersId)
On Delete Set Default
On Update Set Default

--Dikkat !! Default deÄŸer aana tablodaki kaynaÄŸa gÃ¶re olamlÄ±dÄ±r . yukarÄ±daki Ã¶rnekte DersÄ±d iÃ§inde -1 deÄŸeri bulunmadÄ±ÄŸÄ± iÃ§in hata verecektir.

---- Bu ayarlar verilmediÄŸi taktirde "no action" Ã¶zelliÄŸi geÃ§erlidir.




--DeÄŸiÅŸkenler
-- Declare keywordÃ¼ Ä°le DeÄŸiÅŸken tanÄ±mlanÄ±r.
-- Prototip;
--- Declare @DegiskenAdi DegiskenTipi

declare @x int

declare @y nvarchar(50)

declare @z money

declare @x int, @y money, @z bit

declare @Yas int=3


-- TanÄ±mlanmÄ±ÅŸ DeÄŸiÅŸkenlere DeÄŸer Atama

declare @Adi nvarchar(50)='Zehra'

declare @x int

--SET

Set @x=125

declare @tarih datetime

Set @tarih=GETDATE()


-- DeÄŸiÅŸken DeÄŸeri Okuma

declare @x int
set @x=3
select @x
print @x

--Sorgu Sonucu Gelen Verileri DeÄŸiÅŸkenle Elde Etme

declare @Adi nvarchar(max), @Soyadi nvarchar(max)
Select @Adi=Adi,@Soyadi=SoyAdi  from Personeller where  PersonelID=1
Print @Adi+ ' ' + @Soyadi
-- 1. Sorgu sonucu gelen satÄ±r sayÄ±sÄ± bir adet olmalÄ±dÄ±r.
-- 2. Kolonlardaki verilerin tipleri ne ise c verileri temsil edecek deÄŸiÅŸkenlerin tipleride benzer olmalÄ±dÄ±r.






--Batch KavramÄ± - Go
-- yazÄ±lan kodlarÄ± farklÄ± iÅŸ parcÃ§acÄ±klarÄ±na ayrÄ±ldÄ±ÄŸÄ±nÄ± compailer'a ifade eden keyworddÃ¼r.

Create Database OrnekDatabase
Use OrnekDataBase
Create Table OrnekTable
(
 Id int primary key identity (1,1),
 Adi nvarchar(max),
 Soyadi nvarchar(max)
)

Insert Into OrnekTable Values('OÄŸuzhan','Dilek')
Select * from OrnekTable





--IF YapÄ±sÄ±

-- = : EÅŸitse
-- <> : EÅŸit DeÄŸilse
-- > : BÃ¼yÃ¼ktÃ¼r
-- < : KÃ¼Ã§Ã¼ktÃ¼r

--Tek SatÄ±rlÄ±k Ã‡alÄ±ÅŸma

Declare @Isim nvarchar(max)
Set @Isim='Dilek'

if @Isim='Dilek'
	print 'Evet'
Else
	Print 'HayÄ±r'

-- Begin-End YapÄ±sÄ± (Scope)
--KoÅŸu sonucu birden fazla iÅŸlem yapÄ±lacaksa Begin_end ile scoplanÄ±r.
declare @Sayi1 int=2, @Sayi2 int=5

if @Sayi1> @Sayi2
	Begin
		print 'Evet SayÄ±1 SayÄ±2 den BÃ¼yÃ¼ktÃ¼r'
		select @Sayi1 [SayÄ± 1], @Sayi2 [SayÄ± 2]
	End
Else
	Begin
		print 'HayÄ±r SayÄ±1 SayÄ±2 den kÃ¼Ã§Ã¼ktÃ¼r'
		select @Sayi1 [SayÄ± 1], @Sayi2 [SayÄ± 2]
	End

--Ã–rnek 1
--- MÃ¼ÅŸteriler tablosunda AmerikalÄ± (USA) mÃ¼ÅŸteri var mÄ±?
Use Northwind
select * from Musteriler where Ulke='USA'
if @@ROWCOUNT>0 
	print 'Evet'
Else
	Print 'HayÄ±r'

---- Ã–rnek 2
--- AdÄ± 'OÄŸuzhan'
--soyadÄ± 'Dilek' olan Personel var mÄ±? Varsa evet var desin. Yoksa kaydetsin.

Use Northwind
Declare @adi nvarchar(max)='Rumeysa', @soyadi nvarchar(max)='Dilek'
Select * from Personeller where Adi=@adi and SoyAdi=@soyadi
if @@ROWCOUNT>0
	print 'Evet Var'
Else
	Begin
	insert into Personeller(Adi,Soyadi) values(@adi,@soyadi)
	print 'hayÄ±r yok ama eklendi'
	End

--- If-Else If- Else YapÄ±sÄ±

declare @adi nvarchar(max)='OÄŸuzhan', @Yas int=33

if @adi='Mahmut'
	print 'evet'
Else if @Yas>24
	print 'Evet yaÅŸÄ± 24-ten bÃ¼yÃ¼k'
Else
	print 'hayÄ±r'



-- Exists Fonksiyonu
--Sorgu sonucu tablonun dolu mu boÅŸ mu olduÄŸunu dÃ¶ndÃ¼ren fonksiyondur

if Exists(Select * from Personeller)
	print 'True'
Else 
	Print 'False'
	

--While DÃ¶ngÃ¼sÃ¼

-- While Åart Komutu

declare @sayi int =0

while @sayi<=100
	Begin
		print @sayi
		set @sayi=@sayi+1
	End


--While DÃ¶ngÃ¼sÃ¼

-- Break Komutu

declare @sayi int =0

while @sayi<=100
	Begin
		print @sayi
		set @sayi=@sayi+1
		if @sayi%5=0
		break
	End
	
	--While DÃ¶ngÃ¼sÃ¼

-- Contiune Komutu

declare @sayi int =0

while @sayi<=100
	Begin
		if @sayi%5=0
			begin
				set @sayi=@sayi+1
				continue
		end
		print @sayi
		set @sayi=@sayi+1
	
	End
	
	
	
--- GeÃ§ici Tablolar - Temporary Tables

-- Genellikle bir SQL Server Ã¼zerinde farklÄ± lokasyonlarda birden fazla kiÅŸinin Ã§alÄ±ÅŸtÄ±ÄŸÄ± durumlarda ya da verilerin test amaÃ§lÄ± geÃ§ici bir yerlerde tutulmasÄ±, iÅŸlenmesi amacÄ±yla kullanÄ±lan yapÄ±lardÄ±r.
--- Bilinen tablo yapÄ±sÄ±nÄ±n aynÄ±sÄ±nÄ± saÄŸlarlar. Tek farklarÄ± fiziksel olarak oluÅŸmazlar. Sadece bellekte geÃ§ici olarak oluÅŸturulurlar.
--- Select, insert, Update ve Delete iÅŸlemleri yapÄ±labilir. Ä°liÅŸki kurulabilir.
-- Sunucu kapatÄ±ldÄ±ÄŸÄ±nda ya da oturum sahibi oturumu kapattÄ±ÄŸÄ±nda bellekten silinirler.


--- #Bir Tabloyu Fiziksel Olarak Kopyalama

Select * Into GeciciPersoneller from Personeller
--- Bu ÅŸekilde bir kullanÄ±mda sadece primary key ve foreign key constraintler oluÅŸturulmazlar. Geri kalan herÅŸey birebir fiziksel olarak oluÅŸturulur.

--- *Bir Tabloyu # Ä°fadesi Ä°le BelleÄŸe GeÃ§ici Olarak Kopyalama

select * into #GeciciPersoneller from Personeller

select * from #GeciciPersoneller
insert into #GeciciPersoneller(Adi,SoyAdi) values('Deli','Dolu')
Delete #GeciciPersoneller where Adi='Deli'
Update #GeciciPersoneller set SoyAdi='Manyak' where Adi='OÄŸuzhan'

--- GeÃ§ici tablo Ã¼zerinde her tÃ¼rlÃ¼ iÅŸlemi yapabiliyoruz I
---- # ile oluÅŸturulan tablo, o an SQL Serverda oturum aÃ§mÄ±ÅŸ kiÅŸinin sunucu belleÄŸinde oluÅŸur.
--- Sadece oturum aÃ§an ÅŸahÄ±s kullanabilir.
--- EÄŸer oturum aÃ§an ÅŸahÄ±s SQL Servardan disccnnet olursa bu tablo bellekten silinir.



-- *Bir Tabloyu ## Ä°fadesi Ä°le BelleÄŸe GeÃ§ici Olarak Kopyalama

select * into ##GeciciPersoneller from Personeller

insert into  ##GeciciPersoneller(Adi,SoyAdi) values('Deli','Dolu')
Delete ##GeciciPersoneller where Adi='Deli'
Update ##GeciciPersoneller set SoyAdi='Manyak' where Adi='OÄŸuzhan'
select * from ##GeciciPersoneller

--- ## ile oluÅŸturulan tablo, o an SQL Servarda oturum aÃ§mÄ±ÅŸ kiÅŸinin sunucu belleÄŸinde oluÅŸur.
---- Bu tabloyu oturum aÃ§an ÅŸahÄ±s ve onun SQL ServarÄ±na dÄ±ÅŸardan ulaÅŸan 3. ÅŸahÄ±slar kullanabilir.
--- EÄŸer oturum aÃ§an ÅŸahÄ±s SQL Servardan disccnnet olursa bu tablo bellekten silinir.
--- DiÄŸer bÃ¼tÃ¼n Ã¶zellikleri # Ä°le oluÅŸturulan tablo Ä°le aynÄ±dÄ±r.


-- Uniqueidentifier Veri TÄ°PÄ°
-- inti varchar vs. gibi bir veri tipidir.
--- AldÄ±ÄŸÄ± deÄŸer, rakamlar ve harflerden oluÅŸan Ã§ok bÃ¼yÃ¼k bir sayÄ±dÄ±r.
-- Bundan dolayÄ± bu kolona aynÄ± deÄŸerin birden fazla gelmesi neredeyse imkansÄ±zdÄ±r.
--- O yÃ¼zden tekil bir veri oluÅŸturmak iÃ§in kullanÄ±lÄ±r.

USe OrnekVeriTabani
create table ornektable
(
Id int primary key identity(1,1),
FirstName nvarchar(50),
MailCode uniqueidentifier 

)

--NEWID() Fonksiyonu
insert into ornektable values('OÄŸuzhan',NEWID())

select * from ornektable




---- View YapÄ±sÄ±
--KullanÄ±m
--Genellikle karmaÅŸÄ±k sorgularÄ±n tek bir sorgu Ã¼zerinden Ã§alÄ±ÅŸtÄ±rÄ±labilmesidir.
---- Bu amaÃ§la raporlama iÅŸlemlerinde kullanÄ±labilirler.
--- AynÄ± zamanda gÃ¼venlik ihtiyacÄ± olduÄŸu durumlarda herhangi bir sorgunun 2. - 3. ÅŸahÄ±slardan gizlenmesi amacÄ±yla da kullanÄ±lÄ±rlar.
--- Genel Ã–zellikleri
--Herhangi bir sorgunun sonucunu tablo olarak ele alÄ±p, ondan sorgu Ã§ekilebilmesini saÄŸlarlar.
---- ***Ã–nemli***insert, Update ve Delete yapabilirler. Bu iÅŸlemleri fiziksel tabloya yansÄ±tÄ±rlar. 
---- View yapÄ±larÄ± fiziksel olarak oluÅŸturulan yapÄ±lardÄ±r.
---- View yapÄ±larÄ± normal sorgulardan daha yavaÅŸ Ã§alÄ±ÅŸÄ±rlar.
--Dikkat !
---- Database elemanlarÄ±nÄ± Create komutuyla oluÅŸturuyorduk. View yapÄ±sÄ±da bir database yapÄ±sÄ± olduÄŸu Ä°Ã§in Create komutu Ä°le oluÅŸturacaÄŸÄ±z.

Create View vw_Gotur
As
Select p.Adi+' '+p.SoyAdi [AdÄ± SoyadÄ±],k.KategoriAdi [Kategori AdÄ±], COUNT(s.SatisID) [Toplam SatÄ±ÅŸ] from Personeller p inner join Satislar s on p.PersonelID=s.PersonelID
							inner join [Satis Detaylari] sd on s.SatisID=sd.SatisID
							inner join Urunler u on sd.UrunID=u.UrunID
							inner join Kategoriler k on k.KategoriID=u.KategoriID
							group by p.Adi+' '+p.SoyAdi, k.KategoriAdi 

select * from vw_Gotur

select * from vw_Gotur where [AdÄ± SoyadÄ±] Like '%Robert%'

-- View oluÅŸturulurken kolonlara verilen aliaslar View'den sorgu Ã§ekilirken kullanÄ±lÄ±r.
-- Bir yandan da view'Ä±n kullandÄ±ÄŸÄ± gerÃ§ek tablolarÄ±n kolon isimleri, View iÃ§inde alias tanÄ±mlanarak gizlenilmiÅŸ olunur.
-- View iÃ§inde "order by- kullanÄ±lamaz.
--"Order By" view iÃ§inde deÄŸil, view Ã§alÄ±ÅŸÄ±rken sorgu esnasÄ±nda kullanÄ±lmalÄ±dÄ±r.
Select * from vw_Gotur order by [Toplam SatÄ±ÅŸ]
-- Yok eÄŸer Ä°llaki ben View Ä°Ã§inde "order by" kullanacaÄŸÄ±m diyorsanÄ±z View iÃ§inde "top" korutunu kullanmalÄ±sÄ±nÄ±z.
--- Bu durun Ã§okta tavsiye edilen bir durum deÄŸildir.

-- View Ã¼zerinde insert. Delete ve Update yapÄ±labilir. Bu iÅŸlemler fiziksel tabloya yansÄ±tÄ±lmaktadÄ±rlar.

Create View OrnekViewPersoneller
As
Select Adi,SoyAdi,Unvan from Personeller

Insert Into OrnekViewPersoneller(Adi,SoyAdi,Unvan) values('Faruk','Aslan','Senior DEV')
Update OrnekViewPersoneller set SoyAdi='Karaslan' where SoyAdi='Aslan'
Delete OrnekViewPersoneller where SoyAdi='Karaslan'
Select * from Personeller

--- WÄ°th EncryptÄ°on Komutu
--- EÄŸer yazdÄ±ÄŸÄ±mÄ±z view'in kaynak kodlarÄ±nÄ±, Object Explorer penceresinde "Views" kategorisine saÄŸ tÄ±klayarak Design Mdda aÃ§Ä±p
--gÃ¶rÃ¼ntÃ¼lenmesini istemiyorsak "With Encryption" komutu Ä°le Viewi oluÅŸturmalÄ±yÄ±z.
--- Dikkat !
--"With Encryption" iÅŸleminden sonra vÄ°ew'Ä° oluÅŸturan kiÅŸide dahil kimse komutlarÄ± gÃ¶remez. Geri dÃ¶nÃ¼ÅŸ yoktur. Ancak view'i oluÅŸturan ÅŸahsÄ±n komutlarÄ±n yedeÄŸini bulundurmasÄ± gerekmektedir. Ya da "With Encryption" olmaksÄ±zÄ±n view yapÄ±sÄ±nÄ± yeniden alterlamalÄ±yÄ±z.
--- Dikkat !
--- Bir dikkat etmemiz gereken nokta da "With Encryption" ifadesini "as" keywordÃ¼nden Ã¶nce yazmalÄ±yÄ±z.

create view OrnekViewPersoneller 
With Encryption
as
Select Adi,SoyAdi,Unvan from Personeller
--- Bu iÅŸlemi yaptÄ±ktan sonra Design Modu kapatÄ±lmÄ±ÅŸtÄ±r.


---- WÄ°th Schemabinding Komutu
--- EÄŸer view'in kullandÄ±ÄŸÄ± esas fiziksel tablolarÄ±n kolon isimleri bir ÅŸekilde deÄŸiÅŸtirilir, kolonlarÄ± silinir ya da tablo yapÄ±sÄ± bir ÅŸekilde deÄŸiÅŸikliÄŸe uÄŸrar ise vÄ°ew'Ä°n Ã§alÄ±ÅŸmasÄ± artÄ±k mÃ¼mkÃ¼n olmayacaktÄ±r.
---- View'in kullandÄ±ÄŸÄ± tablolar ve kolonlarÄ± bu tarz iÅŸlemler yapÄ±labilmesi ihtimaline karÅŸÄ± koruma altÄ±na alÄ±nabilir.
---- Bu koruma "With Schemabinding" komutu ile yapÄ±labilir.
--"With Schemabinding" ile view Create ya da Alter edilirken, view'in kullandÄ±ÄŸÄ± tablo, schema adÄ±yla birlikte verilmelidir. Ã¶rneÄŸin, dbo(database owner) bir ÅŸema adÄ±dÄ±r. Åemalar C#'takÄ° namespaceler gibi dÃ¼ÅŸÃ¼nÃ¼lebilir.
----"With Schemabinding" konutuda "As" keywordÃ¼nden Ã¶nce yazÄ±lmalÄ±dÄ±r.

Create Table OrnekTablo
(
 Id int primary key identity(1,1),
 FirstName nvarchar(50),
 Kolon int
)

Create View OrnekViewTablo
With Schemabinding
as
Select Id,FirstName,Kolon from dbo.OrnekTablo

Alter Table OrnekTablo
Alter Column Kolon nvarchar(50)


--- With Check Option Komutu
-- View'in iÃ§erisindeki sorguda bulunan ÅŸarta uygun kayÄ±tlarÄ±n insert edilmesine mÃ¼sade edilip, uymayan kayÄ±tlarÄ±n mÃ¼sade edilmemesini saÄŸlayan bir konuttur.

--"With Encryption" ve "With Schemabinding" komutlarÄ± "As" keywordÃ¼nden Ã¶nce belirtilirken "With Check Option" komutu where ÅŸartÄ±ndan sonra belirtilmelidir.

Create View OrnekViewTabo2
As
Select Id,FirstName,Kolon from OrnekTablo where FirstName like'A%'
With Check Option

Insert OrnekViewTabo2 values('OÄŸuzhan',1) --Eklenemez

Insert OrnekViewTabo2 values('Ahmet',1)--Eklendi









--- Functions - Scalar Function - inline Function

--T -SQL 'de iki tip fonksiyon vardÄ±r.
--Scalar Fonksiyonlar Geriye istediÄŸimiz bir tipte deÄŸer gÃ¶nderen fonksiyon.
--- inline Fonksiyonlar Geriye tablo gÃ¶nderen fonksiyon.

--Bu her iki fonksiyonda fiziksel olarak veritabanÄ±nda oluÅŸturulmaktadÄ±r.
--Create komutu ile oluÅŸturulmaktadÄ±r.
--- Ãœzerinde Ã§alÄ±ÅŸÄ±lan database'in Programmability -> Functions kombinasyonundan oluÅŸturulan fonksiyonlara eriÅŸebilmekteyiz.


--â€” 1. Scalar Function â€”
---- Fonksiyon TanÄ±mlama
--- Scalar fonksiyonlara tanÄ±mlandÄ±ktan sonra Programmability Functions Scalar- valued Functions kombinasyonundan eriÅŸilebilir.
USE Northwind
Create Function Topla(@Sayi1 int, @Sayi2 int) Returns int 
As
	Begin
		return @Sayi1 + @Sayi2
	End
--OluÅŸturulan bu fonksiyonu dÃ¼zeltmek isterseniz Programmability->Sclar-valued Functions klasÃ¶rÃ¼nden ismin Ã¼zerine gelip saÄŸ tÄ±klayÄ±nca Modify seÃ§ilerek dÃ¼zeltme yapÄ±labilir.

--- Fonksiyon KullanÄ±mÄ±
--- Fonksiyonu kullanÄ±rken ÅŸemasÄ±yla beraber Ã§aÄŸrÄ±lmalÄ±dÄ±r.

select dbo.Topla(2,1)
print dbo.Topla(3,5)

--Ã–rnek
--"Northwindâ€ veri tabanÄ±nda; herhangi bir Ã¼rÃ¼nÃ¼n %18 KDV dahil olmak Ã¼zere toplam maliyetini getiren fonksiyonu yazalÄ±m.

Create Function Maliyet(@BirimFiyati int, @StokMiktari int) Returns nvarchar(max)
As
	Begin
		declare @sonuc int=@BirimFiyati*@StokMiktari*1.18
		return @sonuc
	End
Select dbo.Maliyet(10,20)


--2. inline Function
--- Geriye bir deÄŸer deÄŸil, tablo gÃ¶nderen fonksiyonlardÄ±r.
--Geriye tablo gÃ¶ndereceÄŸi iÃ§in bu fonksiyonlar Ã§alÄ±ÅŸtÄ±rÄ±lÄ±rken sanki bir tablodan sorgu Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r gibi Ã§alÄ±ÅŸtÄ±rÄ±lÄ±rlar. Bu yÃ¶nleriyle viewlara benzerler. View ile yapÄ±lan iÅŸlevler inline Functions â€¢ lapla yapÄ±labilir.
--Genellikle viewle benzer iÅŸlevler iÃ§in View kullanÄ±lmasÄ±nÄ± Ã¶neririm.

--- Fonksiyon TanÄ±mlama
--- inline fonksiyonlara tanÄ±mlandÄ±ktan sonra Programmability -> Functions->Table-valued Functions kombinasyonundan eriÅŸilebilir.
--Dikkat !
--- inline Function oluÅŸturulurken Begin End yapÄ±sÄ± kullanÄ±lmaz.

Create Function fc_Gonder(@Ad nvarchar(20), @Soyad nvarchar(20)) Returns Table
As
	return Select Adi,Soyadi from Personeller where Adi=@Ad and SoyAdi=@Soyad

--Fonksiyon KullanÄ±mÄ±
--- Fonksiyonu ÅŸemasÄ±yla birlikte Ã§aÄŸÄ±rmak gerekmektedir.
select * from dbo.fc_Gonder('OÄŸuzhan','Dilek')


---- Fonksiyonlarda With Encryption Komutu
--EÄŸer ki yazmÄ±ÅŸ olduÄŸumuz fonksiyonlarÄ±n kodlarÄ±na 2. 3. ÅŸahÄ±slarÄ±n eriÅŸimini engellemek istiyorsak â€With Encryption" komutunu kullanmalÄ±yÄ±z.
--â€With Encryptionâ€ iÅŸleminden sonra fonksiyonu oluÅŸturan kiÅŸide dahil kimse komutlarÄ± gÃ¶remez. Geri dÃ¶nÃ¼ÅŸ yoktur. Ancak fonksiyonu oluÅŸturan ÅŸahsÄ±n komutlarÄ±n yedeÄŸini bulundurmasÄ± gerekmektedir. Ya da "With Encryptionâ€ olmaksÄ±zÄ±n fonksiyonu yeniden alterlamalÄ±yÄ±z.
--"With Encryption" "As" key wordÃ¼nden Ã¶nce kullanÄ±lmalÄ±dÄ±r.

Create function OrnekFunc() Returns int
With Encryption
As
	Begin
	return 3
	End
Go
Select dbo.OrnekFunc()

Create function OrnekFunc2() Returns Table
With Encryption
As
	Return select * from Personeller

select * from dbo.OrnekFunc2()

--Encryption ettiÄŸimiz fonksiyonlarÄ± Alter ile Encryption'larÄ±nÄ± kaldÄ±ryoruz

Alter Function OrnekFunc() Returns int
as
	Begin
		return 3
	End

Alter function OrnekFunc2() Returns Table
As
	return Select * from Personeller


---- Otomatik Hesaplanabilir Kolonlar - Computed Column
--- Herhangi bir kolonda fonksiyon kullanÄ±larak otomatik hesaplanabilir kolonlar
--(Computed Column) oluÅŸturmak mÃ¼mkÃ¼ndÃ¼r.

Create function Topla(@Sayi1 int, @Sayi2 int) returns int
as
	Begin
		return @Sayi1+@Sayi2
	End
Select UrunAdi, dbo.Topla(BirimFiyati,HedefStokDuzeyi) HesapnamisKolon  from Urunler
--Ã–rnek:
--Ã‡Ä±ktÄ± olarak "_____kategorisindeki ____Ã¼rÃ¼nÃ¼nÃ¼n toplam fiyatÄ± __' dÄ±r. "ÅŸeklinde bir Ã§Ä±ktÄ± veren fonksiyonu yazalÄ±m.
Create function Rapor(@Kategori nvarchar(max),@UrunAdi nvarchar(max), @BirimFiyati int, @Stok int) Returns nvarchar(max)
As
	Begin
		declare @Cikti nvarchar(max) = @Kategori + ' kategorisindeki ' + @UrunAdi + ' Ã¼rÃ¼nÃ¼n toplam fiyatÄ± ' + CAST(@BirimFiyati*@Stok as nvarchar(max)) + 'dÄ±r.'  
		return @Cikti
	End

Select dbo.Rapor(k.KategoriAdi,u.UrunAdi,u.BirimFiyati,u.HedefStokDuzeyi) From Urunler u join Kategoriler k on u.UrunID=k.KategoriID








----- Stored Procedures (SaklÄ± Yordamlar)
------ Genel Ã–zelliklerÄ±

----Normal sorgulardan daha hÄ±zlÄ± Ã§alÄ±ÅŸÄ±rlar.
----Ã‡Ã¼nkÃ¼ normal sorgular Execute edilirken "Execute Planâ€ iÅŸlemi yapÄ±lÄ±r. Bu iÅŸlem sÄ±rasÄ±nda hangi tablodan veri Ã§ekilecek, hangi kolonlardan gelecek, bunlar nerede v.s gibi iÅŸlemler yapÄ±lÄ±r. Bir sorgu her Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda bu iÅŸlemler aynen tekrar tekrar yapÄ±lÄ±r. Fakat sorgu Stored Procedure olarak Ã§alÄ±ÅŸtÄ±rÄ±lÄ±rsa bu iÅŸlem sadece bir kere yapÄ±lÄ±r ve o da ilk Ã§alÄ±ÅŸtÄ±rma esnasÄ±ndadÄ±r. DiÄŸer Ã§alÄ±ÅŸtÄ±rmalarda bu iÅŸlemler yapÄ±lmaz. Bundan dolayÄ± hÄ±z ve performansta artÄ±ÅŸ saÄŸlanÄ±r.
----Ä°Ã§erisinde Select, insert, Update ve Delete iÅŸlemleri yapÄ±labilir.
----iÃ§ iÃ§e kullanÄ±labilir.
----Ä°Ã§lerinde fonksiyon olutÅŸrulabilir.
----- SorgularÄ±mÄ±zÄ±n dÄ±ÅŸarÄ±dan alacaÄŸÄ± deÄŸerler parametre olarak Stored Procedure' lere geÃ§irilebildiÄŸinden dolayÄ±, sorgularÄ±mÄ±zÄ±n "SQL Injectionâ€ yemelerinide Ã¶nlemiÅŸ oluruz. Bu yÃ¶nleriyle de daha gÃ¼venlidirler.
----- Stored Procedure fiziksel bir veritabanÄ± nesnesidir. Haliyle Create komutu ile oluÅŸturulur.
----- Fiziksel olarak ilgili veritabanÄ±nÄ±n "Programmabilityâ€ "Stored Procedures" kombinasyonundan eriÅŸilebilirler.

--Prototip -
--- Create Proc ya da Procedure [Ä°sim]
--(
--varsa parametreler
--)
--yazÄ±lacak sorgular, kodlar, ÅŸartlar,fonksiyonlar,komutlar



-- Stored Procedure TanÄ±mlama

Create Proc sp_Ornek
(
	@Id int --Aksi sÃ¶ylenmediÄŸi taktirde bu parametrenin yapÄ±sÄ± inputtur. Yani output keyword'Ã¼ ile deÄŸiÅŸtirlebilir. Ama default input'tur
)
As
Select * from Personeller where PersonelID=@Id
--Dikkat !
--- ProsedÃ¼rÃ¼n parametrelerini tanÄ±mlarken parantez kullanmak zorunlu deÄŸildir ama okunabilirliÄŸi arttÄ±rmak iÃ§in kullanmakta fayda vardÄ±r.

Create Procedure sp_Ornek2
	@Id int,
	@Parametre1 int,
	@Parametre2 nvarchar(max)
As
Select * from Personeller where PersonelID=@Id

---- Stored Procedure KullanÄ±mÄ±
--- Stored Procedure yapÄ±larÄ±nÄ± "Exec" komutu eÅŸliÄŸinde Ã§alÄ±ÅŸtÄ±rabilmekteyiz.

Exec sp_Ornek 3

Exec sp_Ornek2 4,4,'ASD'


-- Geriye DeÄŸer DÃ¶ndÃ¼ren Stored Procedure YapÄ±sÄ±

Create Proc urunGetir
(
	@Fiyat money
)
As
Select * from Urunler where BirimFiyati>@Fiyat
Return @@Rowcount

--KullanÄ±mÄ±
Exec urunGetir 40
--Bu ÅŸekilde geriye dÃ¶nÃ¼len deÄŸeri elde etmeksizin kullanÄ±labilir. SÄ±kÄ±ntÄ± olmaz.

Declare @Sonuc int
Exec @Sonuc=urunGetir 40
print CAST(@Sonuc as nvarchar(max))+ ' adet Ã¼rÃ¼n iÅŸlemden etkilenmiÅŸitr'

--___ OUtPut Ä°le DeÄŸer DÃ¶ndÃ¼rme---

Create Proc sp_Ornek3
(
	@Id int,
	@Adi nvarchar(max) output,
	@Soyadi nvarchar(max) output
)As
Select @Adi=Adi, @Soyadi=SoyAdi  from Personeller where PersonelID=@Id

Declare @Adi nvarchar(max), @Soyadi nvarchar(max)
Exec sp_Ornek3 3,@Adi Output,@Soyadi output
select @Adi+' '+@Soyadi

---Genel Ã–rnek---

--DÄ±ÅŸarÄ±dan aldÄ±ÄŸÄ± isim,soyisim ve ÅŸehir bilgilerini Personeller tablosunda igili kolonlara ekleyen Stored Procedure'Ã¼ yazÄ±nÄ±z.

create procedure sp_PersonelEkle
(
	
	@Adi nvarchar(50),
	@Soyadi nvarchar(50),
	@Sehir nvarchar(50)
) As
	Insert Into Personeller(Adi,Soyadi,Sehir) values(@Adi,@Soyadi,@Sehir)

	Exec sp_PersonelEkle 'OÄŸuzhan','Dilek','Erzurum'

	select * from Personeller


---Parametreler VarsÄ±yaln DeÄŸer---

Create Proc sp_PersonelEkle2
(
	@Adi nvarchar(50)='Ä°simsiz',
	@Soyadi nvarchar(50)='SoyadsÄ±z',
	@Sehir nvarchar(50)='Åehisiz'
)
As 
	Insert Into Personeller(Adi,Soyadi,Sehir) values(@Adi,@Soyadi,@Sehir)
	Select * from Personeller

Exec sp_PersonelEkle2 'Zehra','Dilek','Akara'
--Burada varsayÄ±lan deÄŸerler devreye girmemektedir.

exec sp_PersonelEkle2
--- Normalde bu ÅŸekilde parametrelere deÄŸer gÃ¶ndermeksizin Ã§alÄ±ÅŸmamasÄ± lazÄ±m ama varsayÄ±lan deÄŸerler tanÄ±mda belirtildiÄŸi iÃ§in devreye girmektedirler.

exec sp_PersonelEkle2 'SÃ¼tlaÃ§'
--@Adi parametresi SÃ¼tlaÃ§ deÄŸerini alacaktÄ±r. DiÄŸer parametreler varsayÄ±lan deÄŸerleri.


--EXEC Komutu

Exec(' Select * from Personeller')
Select * from Personeller

--YanlÄ±ÅŸ KullanÄ±m

Exec ('Declare @Sayac int=0')
Exec ('Select @Sayac')

--DoÄŸru KullanÄ±mÄ±
Exec(' Declare @Sayac int=0 Select @Sayac')


---- Stored Procedure iÃ§erisinde Nesne OluÅŸturma

Create Proc sp_TabloOlustur
(
	@TabloAdi nvarchar(max),
	@Kolon1Adi nvarchar(max),
	@Kolon1Ozellikleri nvarchar(max),
	@Kolon2Adi nvarchar(max),
	@Kolon2Ozellikleri nvarchar(max)
)
as
Exec
('
Create Table '+ @TabloAdi+ '
(	'	+ @Kolon1adi+' '+ @Kolon1Ozellikleri+',
	'	+ @Kolon2Adi +' '+ @Kolon2Ozellikleri +'
	
)
')

Exec sp_TabloOlustur 'OrnekTablo','Id','int primary key identity (1,1)','Adi','nvarchar(50)'

drop proc sp_TabloOlustur







--- T -SQL - Triggers (Tetikleyiciler)
--DML Trigger
--- Bir tabloda insert, Update ve Delete iÅŸlemleri gerÃ§ekleÅŸtirildiÄŸinde devreye giren yapÄ±lardÄ±r.Bu Ä°ÅŸlemler sonucunda veya sÃ¼recinde devreye girerler.
--DDL Trigger
--Create, Alter ve Drop Ä°ÅŸlemleri sonucunda veya sÃ¼recinde devreye girecek Olan yapÄ±lardÄ±r.


----DML Trigger----

--- Bir tabloda insert, Update ve Delete iÅŸlemleri gerÃ§ekleÅŸtirildiÄŸinde devreye giren yapÄ±lardÄ±r.
--Bu Ä°ÅŸlemler sonucunda veya sÃ¼recinde devreye girerler.
--- *inserted Table
--- EÄŸer bir tabloda insert iÅŸlemi yapÄ±lÄ±yorsa arka planda iÅŸlemler ilk Ã¶nce RAM' de oluÅŸturulan inserted isimli bir tablo Ã¼zerinde yapÄ±lÄ±r. EÄŸer iÅŸlemde bir problem yoksa inserted tablosundaki veriler fiziksel tabloya insert edilir. Ä°ÅŸlem bittiÄŸinde RAM' de oluÅŸturulan bu inserted tablosu silinir.
--- *Deleted Table
--- EÄŸer bir tabloda delete Ä°ÅŸlemi yapÄ±lÄ±yorsa arka planda Ä°ÅŸlemler Ä°lk Ã–nce RAM' de oluÅŸturulan deleted Ä°simli bir tablo Ãœzerinde yapÄ±lÄ±r. EÄŸer Ä°ÅŸlemlerde bir problem yoksa deleted tablosundaki veriler fiziksel tablodan silinir. Ä°ÅŸlem bittiÄŸinle RAM 'den bu deleted tablosuda silinecektir.
--- EÄŸer bir tabloda update iÅŸlemi yapÄ±lÄ±yorsa RAM' de updated Ä°simli bir tablo OLUÅTURULMAZ! ! !
--- SQL Server'da ki Update mantÄ±ÄŸÄ± Ã¶nce silme(delete), sonra eklemedir(insert) .
--- EÄŸer bir tabloda update iÅŸlemi yapÄ±lÄ±yorsa arka planda RAM' de hem deleted hemde inserted tablolarÄ± oluÅŸturulur ve iÅŸlemler bunlar Ã¼zerinde yapÄ±lÄ±r.
--- NOT : Update yaparken gÃœnceIIenen kaydÄ±n orjinaIÄ° deleted tablosunda, gÃœnceIIendÄ°kten sonraki hali Ä°se Ä°nserted tablosunda bulunmaktadÄ±r. Ã‡Ã¼nkÃ¼ gÃ¼ncelleme demek kaydÄ± Ã¶nce silmek sonra eklemek demektir.
--- Deleted ve inserted tablolarÄ±, ilgili sorgu sonucu oluÅŸtuklarÄ± iÃ§in o sorgunun kullandÄ±ÄŸÄ± kolonlara da sahip olur. BÃ¶ylece deleted ve inserted tablolarÄ±ndan select sorgusu yapmak mÃ¼mkÃ¼ndÃ¼r.

--- Trigger TanÄ±mlama

--- Prototip
---- Create Trigger [Trigger AdÄ±]
--- on [Ä°ÅŸlem YapÄ±lacak Tablo AdÄ±]
--- after --
--veya for delete, update,insert
--- as
--- [Kodlar]

--- Dikkat !

--- TanÄ±mlanan Triggerlara ilgili tablonun iÃ§erisindeki Triggers sekmesi altÄ±ndan eriÅŸebiliriz.


Create Trigger OrnekTrigger
on Personeller
after insert
as
Select * from Personeller
----
Insert Personeller(Adi,SoyAdi) values('OÄŸuzhan','Dilek')

--Ornek 1
--â€” TedarikÃ§iler tablos dan bir veri silindiÄŸinde tÃ¼m Ã¼rÃ¼nlerin fiyatÄ± otomatik olarak 10 artsÄ±n.

Create Trigger triggerTedarikciler
on Tedarikciler
after delete
as
	Update Urunler set BirimFiyati=BirimFiyati+10 
	Select * from Urunler

Delete from Tedarikciler where TedarikciID=30


-- Ã–rnek 2
--TedarikÃ§iler tablosunda bir veri gÃœnce11endÄ°ÄŸÄ°nde,kategoriler tablosunda"meyve kokteyli" adÄ±nda bir kategori oluÅŸsun : )

Create Trigger trgTedarikGuncellendiginde
on Tedarikciler
for Update
As
	Insert Kategoriler(KategoriAdi) Values('Meyve Kokteyli')

Update Tedarikciler set MusteriAdi='Cemalettin' where TedarikciID=29
Select * from Kategoriler

--- Ã–rnek 3
--- Personeller tablosundan bir kayÄ±t silindiÄŸinde silinen kaydÄ±n adÄ±, soyadÄ±, kim tarafÄ±ndan ve hangi tarihte silindiÄŸi baÅŸka bir tabloya kayÄ±t edilsin. Bir nevi log tablosu misali.
Create Table LogTablosu
(
	Id int primary key identity(1,1),
	Rapor nvarchar(max)
)

Create Trigger triggerPersoneller
on Personeller
after delete
as
	Declare @Adi nvarchar(max), @Soyadi nvarchar(max)
	Select @Adi=Adi, @Soyadi=SoyAdi from deleted
	Insert LogTablosu Values('AdÄ± ve SoyadÄ± '+ @Adi+' '+@Soyadi+' olan personel '+ SUSER_SNAME()+' tarafÄ±ndan' +CAST(Getdate() as nvarchar(max))+' tarihinde silinmiÅŸtir')

Delete from Personeller where PersonelID=1020

select * from logtablosu


-- Ã–rnek 4
--Personeller tablosunda update gerÃ§ekleÅŸtiÄŸi anda devreye giren ve bir log tablosuna "AdÄ± ... olan personel ... yeni adÄ±yla deÄŸiÅŸtirilerek ... kullanÄ±cÄ± tarafÄ±ndan ...  tarihinde gÃœnce11endÄ° kalÄ±bÄ±nda rapor yazan triggerÄ± yazalÄ±m.

create trigger trgPersonellerRapor
on Personeller
after update
as
Declare @EskiAdi nvarchar(max), @YeniAdi nvarchar(max)
Select @EskiAdi=Adi from deleted
Select @YeniAdi=Adi from inserted
Insert LogTablosu values('AdÄ± '+@EskiAdi+' olan personel '+ @YeniAdi + ' yeni adÄ±yla deÄŸiÅŸtirilerek' + SUSER_SNAME()+ ' kullanÄ±cÄ±sÄ± tarafÄ±ndan '+ Cast(getdate() as nvarchar(max))+' tarihinde gÃ¼ncellendi.')

Update Personeller set Adi='Murtaza' where PersonelID=17

select * from logtablosu


-- Multiple Actions Trigger

Create Trigger MultiTrigger
on Personeller
after insert,delete
as
	print 'Merhaba'

Insert Personeller(Adi,SoyAdi) values('Husam','MÃ¼sam')

Delete from Personeller where PersonelID=1022



---- Instead Of Triggerlar 
--- Åu ana kadar insert, Update ve Delete Ä°ÅŸlemleri yapÄ±lÄ±rken ÅŸu ÅŸu Ä°ÅŸlemleri yap mantÄ±ÄŸÄ±yla
--Ã§alÄ±ÅŸtÄ±k. (YanÄ±nda ÅŸunu yap)
---- Instead Of Triggerlar Ä°se Ä°nsert, Update ve Delete Ä°ÅŸlemleri yerine ÅŸu ÅŸu Ä°ÅŸlemleri yap
--mantÄ±ÄŸÄ±yla Ã§alÄ±ÅŸmaktadÄ±rlar. (Yerine ÅŸunu yap)
--- Prototip
---- Create Trigger [Triggers AdÄ±]
--- on [Tablo AdÄ±]
---- Instead Of Delete, insert, Update
--- as
--- [Komutlar]
-- Ã–rnek 5
--- Personeller tablosunda update gerÃ§ekleÅŸtiÄŸi anda yapÄ±lacak gÃ¼ncelleÅŸtirme yerine bir log tablosuna "AdÄ± . olan personel ... yeni adÄ±yla deÄŸiÅŸtirilerek ... kullanÄ±cÄ± tarafÄ±ndan tarihinde gÃ¼ncellenmek istendi. "kalÄ±bÄ±nda rapor yazan triggerÄ± yazalÄ±m.

Create Trigger trgPersonellerRaporInstead
on Personeller
Instead Of update
as
	Declare @EskiAdi nvarchar(max), @YeniAdi nvarchar(max)
	Select @EskiAdi=Adi from deleted
	Select @YeniAdi=Adi from inserted
	Insert LogTablosu values('AdÄ± '+@EskiAdi+' olan personel '+@YeniAdi+' olan personel adÄ±yla deÄŸiÅŸtirilerek ' + SUSER_SNAME() + ' kullanÄ±cÄ± tarafÄ±ndan ' + CAST(Getdate() as nvarchar(max))+' tarihinde gÃ¼ncellenmek istendi.') 

Update Personeller set Adi='Ramiz' where PersonelID=1023

-- Ã–rnek 6
-- Personeller tablosunda adÄ± "Andrewâ€ olan kaydÄ±n silinmesini engelleyen ama diÄŸerlerine Ä°zin veren triggerÄ± yazalÄ±m.
Create Trigger AndrewTrigger
on Personeller
after delete
as
Declare @Adi nvarchar(max)
Select @Adi=Adi from deleted
if @Adi='Andrew'
Begin
	print 'Bu kayÄ±t silinemez'
	rollback --YapÄ±lan tÃ¼m iÅŸlemleri geri alÄ±r. Transaction konusunda detaylÄ± gÃ¶receÄŸiz.
end

Delete from Personeller where PersonelID=1023

--DDL Triggerlar
---- Create, Alter ve Drop iÅŸlemleri sonucunda veya sÃ¼recinde devreye girecek olan yapÄ±lardÄ±r.

Create Trigger DDL_Trigger
On DataBase
For drop_table,alter_table,create_function,create_procedure,drop_procedure --vs. vs.
as
print 'Bu iÅŸlem yapÄ±lamaz'
Rollback

Drop Table LogTablosu --Messages: Bu iÅŸlem gerÃ§ekleÅŸtirilemez.


-- Trigger'l Devre DÄ±ÅŸÄ± BÄ±rakma
Disable Trigger OrnekTrigger on Personeller

-- Trigger'l AktifleÅŸtirme 
Enable Trigger OrnekTrigger on Personeller

--- Transaction
--- Birden Ã§ok iÅŸlemin bir arada yapÄ±ldÄ±ÄŸÄ± durumlarda eÄŸer parÃ§ayÄ± oluÅŸturan iÅŸlemlerden herhangi birinde sorun olursa tÃ¼m Ä°ÅŸlemi iptal ettirmeye yarar.

--- Ã–rneÄŸin; kredi kartÄ± ile alÄ±ÅŸveriÅŸ iÅŸlemlerinde transaction iÅŸlemi vardÄ±r. Siz marketten Ã¼rÃ¼n alÄ±rken sizin hesabÄ±nÄ±zdan para dÃ¼ÅŸÃ¼lecek, marketin hesabÄ±na para aktarÄ±lacaktÄ±r. Bu Ä°ÅŸlemde hata olmamasÄ± gerekir ve bundan dolayÄ± bu iÅŸlem bir transaction bloÄŸunda gerÃ§ekleÅŸtirilmelidir. Bu esnada herhangi bir sorun olursa bÃ¼tÃ¼n iÅŸlemler transaction tarafÄ±ndan iptal edilebilecektir.
--Begin Tran veya Begin Transaction : Transaction Ä°ÅŸlemini baÅŸlatÄ±r.

---- Commit Tran : Transaction iÅŸlemini baÅŸarÄ±yla sona erdirir.Ä°ÅŸlem(ler)i gerÃ§ekleÅŸtirir.
---- Rollback Tran : Transaction iÅŸlemini iptal eder.Ä°ÅŸlem(ler)i geri alÄ±r.

--- Commit Tran yerine sadece Commit yazÄ±labilir.
--- Rollback Tran yerine sadece Rollback yazÄ±labilir.

---- Normalde default olarak herÅŸey Begin Tran ile baÅŸlayÄ±p, Commit Tran ile biter. !!! Biz bu yapÄ±larÄ± kullanmasak bile ! ! !

--- Transaction
--Transaction TanÄ±mlama
--- Prototip
--- Begin Tran [Transaction AdÄ±]
--- Ä°ÅŸlemler

insert	Bolge Values(5, 'Ã‡orum')	--VarsayÄ±lan olarak Transaction	kontrolÃ¼nde	bir	Ä°ÅŸlemdir.	Netice	olarak gene	varsayÄ±lan olarak Commit	Tran olarak bitmektedir.

Begin Tran Kontrol
insert Bolge values(6,'Erzurum')
Commit Tran

-- Transaction'a isim vermek zorunda deÄŸiliz.
Begin Tran 
insert Bolge values(7,'Mars')
Commit Tran

Begin tran Kontrol
Declare @i int 
Delete from Personeller where PersonelID>10
set @i=@@ROWCOUNT
	if @i=1
		Begin
			print 'KayÄ±t silindi'
			Commit
			--ya da
			--Tran Commit
		End
	Else
		Begin
			print 'Ä°ÅŸlemler geri alÄ±ndÄ±'
			Rollback
			--ya da
			-- Tran Rollback
		End

---- Ã–rnek
--- Ä°ki adet banka tablosu oluÅŸturalÄ±m. Bankalar arasÄ± havale iÅŸlemi gerÃ§ekleÅŸtirelim. Ve bu iÅŸlemleri
--yaparken transaction kullanalÄ±m.

---Ã–rnek 121. videoada sonra yapÄ±lacak




--SQL Server Database YedeÄŸi Alma ve YÃ¼kleme

--Backup Ä°le Yedek Alma
-- Restore Ä°le YedeÄŸi YÃ¼kleme

--Backup ile Yedek Alma
--MS SQL Server Management Studio'nun Object Explorer sekmesinden YedeÄŸi alÄ±ncak Databse'in Ã¼stÃ¼ne saÄŸ tÄ±klayÄ±p Tasks->Back Up.. seÃ§ilir.
--AÃ§Ä±lan pencerenin Source bÃ¶lÃ¼mÃ¼nde dikkat etmeniz gereken yer Backup Type olacaktÄ±r. burada 2 farklÄ± seÃ§enek Ã§Ä±kacak.Bunlar;
	--Full
	--Differantial

--Full veritabanÄ±nda veriler dahil iÃ§inde log dosyalrÄ±, triggerlar vs ne varsa yedeÄŸini alackatÄ±r. 
--Differantial ise deÄŸiÅŸiklikleri kapsayan nesneleri alacaktÄ±r.

-- Destination da ise backup yapÄ±lacak ortamÄ± secip (Disk,URL) ardÄ±ndan path'i verip Ok butonu ile yedeÄŸimizi alabiliriz.


---- Restore Ä°le YedeÄŸi YÃ¼kleme
	--
	----MS SQL Server Management Studio'nun Object Explorer sekmesinden YedeÄŸi yÃ¼klnecek Databse'in Ã¼stÃ¼ne saÄŸ tÄ±klayÄ±p Tasks->Restore->Database
	--AÃ§Ä±lan pencerede Source bÃ¶lÃ¼mÃ¼nde Device'Ä± seÃ§ip ilgili backup dosyamÄ±zÄ± dizinden bulup iÅŸaretliyoruz.
	
---Bu yÃ¶ntem basit gibi gÃ¶rÃ¼nsede asÄ±l tavsiye edilen Generate Scripts ile Alma ve YÃ¼keleme olacaktÄ±r.

--- Generate Scripts


/*
===============================================================================
GENARATE SCRIPTS Ä°LE YEDEK ALMA (ÅEMA + VERÄ°) ve YÃœKLEME (AKTARIM) ADIMLARI
===============================================================================

AMAÃ‡:
- SSMS (SQL Server Management Studio) Ã¼zerinden "Generate Scripts" ile bir veritabanÄ±nÄ±n
  ÅŸemasÄ±nÄ± VE/VEYA verisini .sql dosyasÄ± olarak Ã¼retmek ve bu scripti baÅŸka bir
  sunucu/ortama Ã§alÄ±ÅŸtÄ±rarak yÃ¼klemek.

-------------------------------------------------------------------------------
A) YEDEK ALMA: GENERATE SCRIPTS (SSMS GUI)
-------------------------------------------------------------------------------
1) SSMS -> Object Explorer -> kaynak sunucu -> Databases -> {KaynakDB}
2) SaÄŸ tÄ±k {KaynakDB} -> Tasks -> Generate Scripts...
3) "Choose Objects"
   - Script entire database and all database objects  (TÃ¼m veritabanÄ± ve objeler)
     veya
   - Select specific database objects (Sadece seÃ§tiÄŸin tablolar, viewâ€™lar vb.)
4) "Set Scripting Options"
   - Save to file (Ã¶nerilir) -> Save as type: Single file / Unicode olarak kaydedin.
   - (Ä°steÄŸe baÄŸlÄ±) Save to Clipboard / Save to new query window
5) "Advanced" (en Ã¶nemli ayarlar):
   - Types of data to script           : Schema and data     (yalnÄ±z ÅŸema istiyorsan "Schema only")
   - Script Indexes                    : True
   - Script Triggers                   : True
   - Script Primary Keys               : True
   - Script Foreign Keys               : True
   - Script Check Constraints          : True
   - Include IF NOT EXISTS             : True (varsa Ã§akÄ±ÅŸmalarÄ± azaltÄ±r)
   - Script DROP and CREATE            : CREATE (mevcudu silip kuracaksan "DROP and CREATE")
   - Script for Server Version         : Hedef SQL Server sÃ¼rÃ¼mÃ¼ne gÃ¶re seÃ§ (Ã¶rn. SQL Server 2019)
   - Script Collation                  : Hedefle aynÄ± kolasyon kullanacaksan False; kaynak kolasyonu aynen taÅŸÄ±mak istersen True
   - Script USE DATABASE               : True (hedef DB adÄ±nÄ± kolay deÄŸiÅŸtirmek iÃ§in faydalÄ±)
   - Script Permissions                : True (gerekliyse)
6) Next -> Next -> Finish -> OluÅŸan .sql dosyasÄ±nÄ± gÃ¼venli bir yerde sakla.
   (Ã–rn: MyDb_20250818_SchemaData.sql)

-------------------------------------------------------------------------------
B) YÃœKLEME/AKTARIM: OLUÅAN SCRIPTÄ° HEDEFTE Ã‡ALIÅTIRMA
-------------------------------------------------------------------------------
Ã–nkoÅŸullar:
- Hedef SQL Server sÃ¼rÃ¼mÃ¼, scriptte seÃ§tiÄŸin "Script for Server Version" ile uyumlu olmalÄ±.
- BÃ¼yÃ¼k veri setlerinde iÅŸlem uzun sÃ¼rebilir; mÃ¼mkÃ¼nse hedefte boÅŸ/temiz bir DB kullan.

AdÄ±mlar:
1) SSMS ile HEDEF sunucuya baÄŸlan.
2) (Gerekirse) hedefte veritabanÄ± oluÅŸtur:
   - New Databaseâ€¦ (GUI) veya
   - CREATE DATABASE HedefDB;  (Script iÃ§inde CREATE varsa ayrÄ±ca gerekmez)
3) OluÅŸturduÄŸun .sql dosyasÄ±nÄ± SSMSâ€™te aÃ§.
4) En Ã¼stteki "USE [VeritabaniAdi]" bÃ¶lÃ¼mÃ¼nÃ¼ HEDEF veritabanÄ± adÄ±na gÃ¶re dÃ¼zenle.
5) (Varsa) dosyanÄ±n baÅŸÄ±ndaki CREATE DATABASE kÄ±smÄ±ndaki fiziksel yol/kolasyon ayarlarÄ±nÄ± hedefe uygun yap.
6) "Execute" (F5) ile Ã§alÄ±ÅŸtÄ±r.
   - BÃ¼yÃ¼k scriptlerde Ã¶nce "Parse" ile sentaks kontrolÃ¼ yapabilirsin.
   - Ã‡alÄ±ÅŸma sÄ±rasÄ±nda SET IDENTITY_INSERT ve constraint disable/enable adÄ±mlarÄ±nÄ± script genelde otomatik yÃ¶netir.

-------------------------------------------------------------------------------
C) SIK KARÅILAÅILAN DURUMLAR ve Ä°PUÃ‡LARI
-------------------------------------------------------------------------------
- Ã‡ift kayÄ±t/PK hatasÄ± (2627): Hedefte aynÄ± veri varsa Ã¶nce temizle (DROP/Truncate) veya scripti
  "DROP and CREATE" seÃ§eneÄŸiyle yeniden Ã¼ret.
- YabancÄ± anahtar (FK) sÄ±rasÄ±: Advancedâ€™de FK/PK/Indexes/Checks TRUE ise sÄ±rayÄ± genelde doÄŸru kurar.
  Sorun olursa iki parÃ§a Ã¼ret: Ã¶nce "Schema only", sonra "Data only" ve sÄ±rayla Ã§alÄ±ÅŸtÄ±r.
- Kolasyon uyuÅŸmazlÄ±ÄŸÄ±: Hedef DBâ€™yi kaynakla aynÄ± kolasyonda oluÅŸtur veya Advanced -> Script Collation = True.
- Yetkiler/Loginler: Script Permissions = True ile objelere ait GRANT/REVOKE gelir.
  KullanÄ±cÄ±-login eÅŸlemesi iÃ§in sonrasÄ±: ALTER USER [kullanici] WITH LOGIN = [loginAdi];
- BÃ¼yÃ¼k/veri yoÄŸun DBâ€™ler: Generate Scripts uzun sÃ¼rer. BÃ¶yle durumlarda klasik .bak restore veya .bacpac (Export Data-tier Application)
  daha hÄ±zlÄ±/uygun olabilir.

-------------------------------------------------------------------------------
D) HIZLI Ã–RNEK (SADECE SEÃ‡Ä°LÄ° TABLOLAR, ÅEMA+VERÄ°)
-------------------------------------------------------------------------------
1) Tasks -> Generate Scripts -> Select specific database objects -> Tables -> dbo.Personeller (+ diÄŸerleri)
2) Set Scripting Options -> Save to file (Unicode) -> Advanced:
   - Types of data to script = Schema and data
   - Script Indexes/Triggers/PK/FK/Checks = True
   - Include IF NOT EXISTS = True
3) Generate -> Hedefte .sql dosyasÄ±nÄ± aÃ§ -> USE [HedefDB] satÄ±rÄ±nÄ± kontrol et -> Execute.

-------------------------------------------------------------------------------
E) NE ZAMAN HANGÄ° YÃ–NTEM?
-------------------------------------------------------------------------------
- Generate Scripts: KÃ¼Ã§Ã¼k/orta Ã¶lÃ§ek, seÃ§meli obje taÅŸÄ±ma, sÃ¼rÃ¼m uyumu ve kaynak kontrol iÃ§in ideal.
- .bak ile Restore: En hÄ±zlÄ± ve tam kopya; bÃ¼yÃ¼k veriler iÃ§in tercih edilir.
- .bacpac: Azure/versiyon geÃ§iÅŸlerinde ÅŸema+veri taÅŸÄ±ma iÃ§in pratik.

NOT:
- Bu notlar SSMS iÃ§indeki "Generate Scripts" sÃ¼recini Ã¶zetler. Gerekirse aynÄ± iÅŸlemleri
  PowerShell/SMO ile otomatikleÅŸtirebilirsin.
===============================================================================
*/




--- T-SQL En Son Primary Key ID yi Bulmak
Select IDENT_CURRENT('Personeller')
Select IDENT_CURRENT( 'Personeller') + 1

--ldentity, Scope_Identity() ve Ident_Current ( ) KomutlarÄ±

-- AÃ§Ä±lmÄ±ÅŸ olan baÄŸlantÄ±da(connection); tablo yahut sorgunun Ã§alÄ±ÅŸtÄ±ÄŸÄ± scope'a bakmaksÄ±zÄ±n son Ã¼ret Ä°len
--identity deÄŸerini vermektedir.
-- Dikkat !
-- Trigger kullanÄ±lan sorgularda yanlÄ±ÅŸ sonuÃ§ alma Ä°htimalinden dolayÄ± kullanÄ±lmasÄ± tavsiye edilmez.

-- Scope_ldentity()
-- AÃ§Ä±lmÄ±ÅŸ olan baÄŸlantÄ±da(connection) ve sorgunun Ã§alÄ±ÅŸtÄ±ÄŸÄ± scope'ta son Ã¼retilen identity deÄŸerini dÃ¶ndÃ¼rÃ¼r.
--Dikkat !
-- Trigger kullanÄ±lan sorgularda â€”Identity yerine bu fonksiyonun kullanÄ±lmasÄ± tavsiye edilir.

-- Ident_Current('TabloAdi')
--BaÄŸlantÄ± ve sorgunun Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ± scope'a bakmaksÄ±zÄ±n parametre olarak verilen tabloda Ã¼retilen sonuncu Identity deÄŸerini dÃ¶ndÃ¼rÃ¼r.




--- Default Values Ä°le Sadece Identity Kolonuna Veri Eklemek
--- EÄŸer ki veritabanÄ±nda gÃ¶revi sadece diÄŸer tablolar tarafÄ±ndan referans alÄ±nacaÄŸÄ± idleri Ã¼retecek ve barÄ±ndÄ±racak olan bir tabloya ihtiyacÄ±nÄ±z varsa kullanÄ±lÄ±r.

---Prototip

Insert OrnekTablo
Default Values


--- Top KeywordÃ¼ Ä°le Update Ä°ÅŸlemi

Select top 5 * from Personeller
Update top(5) Personeller set Adi='Updated'
Delete top(5) from Personeller


--- T-SQL ROW NUMBER Fonksiyonu
---- Prototipi
--- Select ROW_NUMBER() OVER(order by KOLONAdi) Indexer, * from Tablo


select ROW_NUMBER() OVER(Order by Adi) Indexer ,  * from Personeller order by SoyAdi



--- Partition By Komutu ile Gruplama
--- Prototip
--- Select ROW_NUMBER() OVER(partition by Kolon1 order by Kolon2) Indexer, * from Tablo

Select ROW_NUMBER() Over(partition by MusteriID order by Satistarihi) indexer, * from Satislar order by SatisID


-- T-SQL ANSI NULLS Komutu

-- SET ANSI_NULLS [ ON I OFF ]

-- ANSI NULLS komutu, where ÅŸartlarÄ±nda kontrol edilen eÅŸitlik yahut eÅŸit deÄŸil lik durumlarÄ±nda Null deÄŸerlerin dikkate alÄ±nÄ±p alÄ±nmayacaÄŸÄ±nÄ± belirlememizi saÄŸlayan bir Ã¶zelliktir.

--'ON' deÄŸeri verilirse Null deÄŸerler dikkate alÄ±nmaz.
-- 'OFF' deÄŸeri verilirse Null deÄŸerler dikkate alÄ±nÄ±r.

set ansi_nulls on

select * from Personeller where Unvan=null

set ansi_nulls off







--- Dynamic Data Masking



--SQL Serverâ€™da Dynamic Data Masking (DDM), veritabanÄ±ndaki hassas bilgilerin (TC kimlik no, telefon, e-posta vb.) yetkisiz kullanÄ±cÄ±lar tarafÄ±ndan gÃ¶rÃ¼lmesini engellemek iÃ§in kullanÄ±lan bir gÃ¼venlik Ã¶zelliÄŸidir.

--DDM, verinin fiziksel olarak deÄŸiÅŸtirilmesini saÄŸlamaz; sadece sorgu sonucu dÃ¶nerken maskeleme uygular. Yani tablo iÃ§inde gerÃ§ek veri durur, ancak maskeleme kurallarÄ± tanÄ±mlanmÄ±ÅŸsa, yetkisi olmayan kullanÄ±cÄ± veriyi kÄ±smi veya sahte biÃ§imde gÃ¶rÃ¼r.

--Ã–rnek:

--GerÃ§ek veri: 1234-5678-9012-3456

--MaskelenmiÅŸ gÃ¶rÃ¼nÃ¼m: XXXX-XXXX-XXXX-3456

--AvantajlarÄ±:

--UygulamayÄ± deÄŸiÅŸtirmeden hÄ±zlÄ± ÅŸekilde uygulanabilir.

--Hassas veriye eriÅŸimi kontrol altÄ±na alÄ±r.

--KÄ±sÄ±tlarÄ±:

--YalnÄ±zca SELECT sonuÃ§larÄ±nda geÃ§erlidir.

--YÃ¶netici (db_owner) roller maskeyi gÃ¶rmez, gerÃ§ek veriye eriÅŸir.


--- default Parametresi
-- Metinsel : XXXX
-- sayÄ±sal : 0000
-- Tarihsel : 01.01.2000 00:00:00.00000000
-- Binary : 0 -> ASCII

-- email Parametresi
-- odilek@gmail.com : 'oxxx@xxxx.com' 


--Partial Parametresi
-- Partia1(3, H, 2) // ilk 3 karakter gizleme, maske karakteri H olsun, son 2 karakter maskeleme olmasÄ±n


--Dynamic Data Masking NasÄ±l UygulanÄ±r?
-- Prototip
--CREATE TABLE [TABLO ADI]
--[KOLON ADI] [KOLON Tipi] MASKED WITH (FUNCTION = ' default() ' )

use OrnekDatabase
Create Table Ogrenciler
(
	Ogrenci_Id int primary key identity(1,1),
	Adi nvarchar(20) masked with (function='default()') null,
	Soyadi nvarchar(20) masked with (function='default()') null,
	Memleketi nvarchar(20) masked with (function='default()') null,
	TCNo bigint  masked with (function='default()') not null unique,
	Sube nvarchar(1) masked with (function='default()') null,
	eMail nvarchar(max) masked with (function='email()') null,
	Hakkinda nvarchar(max) masked with (function='partial(3, "Ä",2)') null,
	DogumTarihi datetime masked with (function='default()')null,

)

go 

insert into Ogrenciler
(Adi, Soyadi, Memleketi, TCNo, Sube, eMail, Hakkinda, DogumTarihi)
values
(N'Ahmet', N'YÄ±lmaz', N'Erzurum', 12345678901, N'A', N'ahmet.yilmaz@example.com', N'Ã‡ok Ã§alÄ±ÅŸkan bir Ã¶ÄŸrenci', '2002-05-10'),

(N'AyÅŸe', N'Demir', N'Ankara', 23456789012, N'B', N'ayse.demir@example.com', N'Projelerde aktif gÃ¶rev alÄ±r', '2001-11-20'),

(N'Mehmet', N'Ã‡elik', N'Ä°zmir', 34567890123, N'A', N'mehmet.celik@example.com', N'SÄ±nÄ±fÄ±n spor kaptanÄ±', '2003-03-15');


create user YetkiliUser without login --YetkiliUser isminde bir kullanÄ±cÄ± oluÅŸturuluyor.
go
grant select on Ogrenciler to YetkiliUser -- YETKILIUSER isimli kullanÄ±cÄ±ya OGRENCILER tablosunda Select yetkisi veriliyor

execute as user ='YetkiliUser' --YetkiliUser isimli kullanÄ±cdayken 
select * from Ogrenciler
revert;--- Tekrar eski kullanÄ±cÄ±ya dÃ¶n

--Alter Ä°le Kolona Dynamic Data Masking Uygulama

alter table Ogrenciler
add Ekkolon nvarchar(max) masked with (function='partial(3,"Ä",2)') null

update Ogrenciler set ekkolon='Ekkolonn'


--Alter Ä°le Dynamic Data Misking Kolonunda DeÄŸiÅŸiklik Yapma

alter table Ogrenciler
alter column Ekkolon nvarchar(max) masked with (function='partial(3,"XXXX",2)') null

--â€” Dynamic Data Masking KaldÄ±rma

alter table Ogrenciler
alter column Ekkolon drop masked

-- KullanÄ±cÄ±ya GÃ¶re Dynamic Data Massking Ã–zelliÄŸini PasifleÅŸtirme

Grant UNMASK to YetkiliUser
execute as user='YetkiliUser'
select * from Ogrenciler
revert





-- Temporal Tables(System-Versioned Table - Zamansal Tablolar)

--## ğŸ“Œ Temporal Tables (SQL Server 2016)

--**TanÄ±m:**

--* SQL Server 2016 ile gelen bir Ã¶zellik.
--* â€œZamansal tablolarâ€ olarak da bilinir.
--* Veri Ã¼zerindeki **DML (Insert, Update, Delete)** iÅŸlemlerinin geÃ§miÅŸini tutar.
--* Verilerin **zaman bazlÄ± takibini** saÄŸlar.

-----

--### ğŸ¯ Temporal Tables ile Gelen Faydalar

--* **Veri deÄŸiÅŸikliklerini izleme** (Update/Delete sonrasÄ± eski halini gÃ¶rebilme).
--* YanlÄ±ÅŸlÄ±kla yapÄ±lan **Delete/Update iÅŸlemlerini geri getirme** (Transaction deÄŸil, gerÃ§ekten fiziksel veri kaybÄ± olsa bile).
--* Belirli bir **zaman aralÄ±ÄŸÄ±nda verinin durumunu** gÃ¶rebilme.
--* Daha **performanslÄ± ve dÃ¼ÅŸÃ¼k maliyetli raporlama**.
--* Ã–nceden kullanÄ±lan **log tablolarÄ±** veya **trigger yapÄ±larÄ±** gibi ek yapÄ±lara gerek yok.

-----

--### ğŸ— YapÄ±

--* Temporal table = **AsÄ±l tablo + History tablosu**
--* **History tablosu** â†’ verilerin geÃ§miÅŸ versiyonlarÄ±nÄ± saklar.
--* Tabloya 2 ekstra kolon eklenir:

--  * `StartDate` â†’ verinin geÃ§erli olmaya baÅŸladÄ±ÄŸÄ± tarih.
--  * `EndDate` â†’ verinin geÃ§erli olmayÄ± bÄ±raktÄ±ÄŸÄ± tarih.
--* Bu kolonlarÄ±n tipi: `datetime2`.

-----

--### âš¡ Ã–zet

--* Temporal Tables = **raporlama sistemi**.
--* Verileri **zamansal (tarih bazlÄ±)** olarak saklar ve analiz etmeye yarar.
--* Ã–zellikle **deÄŸiÅŸikliklerin geÃ§miÅŸini izleme ve raporlama** iÃ§in idealdir.

---


--Bir Verinin Zamansal Takibi
--- Veri ilk KaydedildiÄŸinde (insert)
--Veri Ä°lk GÃ¼ncellendiÄŸinde (Update)
--- Verinin Sonraki GÃ¼ncellemelerinde (Update)



--- Temporal Tables Ã–zelliÄŸini KullanÄ±rken Nelere Dikkat Etmeliyiz?
---- Temponal Tables Ä°le raporlama ve takip mekanizmasÄ± oluÅŸturacaÄŸÄ±mÄ±z tablolarda Primary Key tanÄ±mlanmÄ±ÅŸ bir kolon olmasÄ± gerekmektedir. Bu ÅŸekilde yaÅŸam dÃ¶ngÃ¼sÃ¼nde hangi verinin deÄŸiÅŸime uÄŸradÄ±ÄŸÄ±nÄ± bu Primary Key aracÄ±lÄ±ÄŸÄ±yla ayÄ±rt edebileceÄŸiz.
---- Takibi saÄŸlayacaÄŸÄ±mÄ±z ve kaydÄ±nÄ± tutacaÄŸÄ±mÄ±z tablomuzun iÃ§erisinde bir baÅŸlangÄ±Ã§(StartDate) birde bitiÅŸ(EndDate) nitelÄŸinde iki adet "datetime2" tipinden kolonlarÄ±n bulunmasÄ± gerekmektedir.
---- Linked Server Ã¼zerinde Temporal Tables kullanÄ±lmamaktadÄ±r.
---- History tablomuzda constraint yapÄ±larÄ±nÄ±n hiÃ§birini uygulayamayÄ±z.
--- EÄŸer bir tabloda Temporal Tables aktifse o tabloda Truncate iÅŸlemi gerÃ§ekleÅŸtiremiyoruz.
---- History tablosunda direkt olarak DML iÅŸlemleri gerÃ§ekleÅŸtiremiyoruz.
---- Tempraol Tables Ã¶zelliÄŸinin bulunduÄŸu bir tabloda Computed Column(HesaplanmÄ±ÅŸ Kolon) tanÄ±mlayamÄ±yoruz.


create table DersKayitlari
(
------------1. KÄ±sÄ±m ------------
	DersId int primary key identity(1,1),
	Ders nvarchar(max),
	Onay Bit,
------------1. KÄ±sÄ±m ------------

------------2. KÄ±sÄ±m ------------
	StartDate Datetime2 generated always as row start not null,
	EndDate Datetime2 generated always as row end not null,
------------2. KÄ±sÄ±m ------------

------------3. KÄ±sÄ±m ------------
	Period for system_time(StartDate,EndDate)
------------3. KÄ±sÄ±m ------------

)

------------4. KÄ±sÄ±m ------------
With(System_Versioning = On(HISTORY_TABLE = dbo.DersKayitlariLog)) --EÄŸer HISTORY_TABLE Ã¶zelliÄŸi ile History tablosuna isim vermezsek rastgele Ä°simde oluÅŸturulur.
------------4. KÄ±sÄ±m ------------


--- Temporal Table Ã‡alÄ±ÅŸma MekanizmasÄ±

update DersKayitlari set Ders='Matematik2' where DersId=1
update DersKayitlari set Ders='Matematik4' where DersId=1

select * from DersKayitlari
select * from DersKayitlariLog



--- Var Olan Tabloyu Temporal Tables Olarak Ayarlama


--- EÄŸer bu tabloyu Temporal yapmak Ä°stiyorsak dikkat !
-- Tablo iÃ§erisinde veri var mÄ±? Yok mu? EÄŸer varsa yeni eklenecek olan "StartDate" ve "EndDate" kolonlarÄ± boÅŸ kalamayacaklarÄ± iÃ§in varsayÄ±lan deÄŸerlerin belirtilmesi gerekmektedir. Yok eÄŸer veri yoksa bu Ä°ÅŸlemi dÃ¼ÅŸÃ¼nmemize gerek olmayacaktÄ±r.

--EÄŸer Veri yoksa
Alter Table Ogrenciler 
Add
StartDate Datetime2 generated always as row start not null,
EndDate datetime2 generated always as row end not null,
Period for system_time(StartDate,EndDate)

--- EÄŸer Veri Varsa.
Alter Table Ogrenciler
Add
StartDate Datetime2 generated always as row start not null default cast('1900-01-01 00:00:00.0000000' as datetime2),
EndDate Datetime2 generated always as row end not null default cast('9999-12-31 23:59:59.9999999' as datetime2),
Period for system_time(StartDate,EndDate)

--- Åeklinde peroyodik kayÄ±t kolonlarÄ±mÄ±zÄ± ekleyebiliriz.

-- Kolonlar eklendikten sonra ilgili tablo aÅŸaÄŸÄ±daki gibi Temporal hale getirilir.

Alter Table Ogrenciler
Set (System_Versioning= On(HISTORY_TABLE=dbo.OgrencilerLog ))


--- History Tablosuna Ã–zel Temponal Tabloyu Sorgulama
--SELECT *  
--FROM DersKayitlari dk  
--INNER JOIN DersKayitlariLog dkl  
--    ON dk.DersID = dkl.DersID  
--WHERE DAY(CAST('2016-09-26' AS datetime2)) = DAY(dkl.EndDate);

--Bu ÅŸekilde iliÅŸkisel tablolar ile de sorgulama yapabiliriz.

--Lakin tablomuzu History tablosunun periyoduna Ã¶zel bir ÅŸekilde de rahatÃ§a sorgulatabilmekteyiz.
- 


--AS OF datetime

--Temporal tablolarÄ±n en gÃ¼Ã§lÃ¼ Ã¶zelliklerinden biridir.
--Belirli bir anÄ± gÃ¶sterir. Sadece tek bir zaman diliminde kaydÄ±n nasÄ±l gÃ¶rÃ¼ndÃ¼ÄŸÃ¼nÃ¼ getirir.
--MantÄ±ksal sorgusu:
--StartDate <= datetime  
--AND EndDate > datetime
select * from DersKayitlari
For System_time as of '2000-08-20 07:57:04.4431646'

-- (FROM â€“ TO) ile Temporal Tablo Sorgulama
--BitiÅŸ zamanÄ± dahil edilmez.
--FROM <start datetime> TO <end datetime>
--MantÄ±ksal sorgusu:
--StartDate >= <start datetime>  
--AND EndDate <= <end datetime>

select * from DersKayitlari
for system_time from '2024-08-20 08:02:17.0465892' to '2025-08-20 08:02:17.0465892'
where DersId=3

--BETWEEN
--... BETWEEN <start_datetime> AND <end_datetime>
--BitiÅŸ zamanÄ± dahil edilir.
--MantÄ±ksal sorgusu:
--StartDate >= <start_datetime>  
--AND EndDate <= <end_datetime>


--CONTAINED IN
--KaydÄ±n tÃ¼m geÃ§erlilik sÃ¼resi verilen aralÄ±ÄŸÄ±n iÃ§inde olmalÄ±dÄ±r.
--... CONTAINED IN (<start_datetime>, <end_datetime>)
--MantÄ±ksal sorgusu:
--StartDate >= <start_datetime>  
--AND EndDate <= <end_datetime>


--Temporal TablolarÄ± Listelemek

-- 1. YÃ¶ntem
SELECT  
    OBJECT_NAME(object_id) AS [Table Name],  
    temporal_type_desc AS [Temporal Type],  
    history_table_id,  
    OBJECT_NAME(history_table_id) AS [History Table Name]  
FROM sys.tables  
WHERE history_table_id IS NOT NULL;

--ya da

-- 2. YÃ¶ntem
SELECT  
    name AS [Table Name],  
    temporal_type_desc AS [Temporal Type],  
    OBJECT_NAME(history_table_id) AS [History Table Name]  
FROM sys.tables  
WHERE temporal_type_desc = 'SYSTEM_VERSIONED_TEMPORAL_TABLE';


--- Temporal Tables'i Pasifize Etme

ALTER TABLE DERSKAYITLARI SET (SYSTEM_VERSIONING=OFF)

Truncate table derskayitlari
Drop Table DersKayitlari
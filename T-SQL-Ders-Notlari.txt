T-SQL DERSLERİ

ServerName alanı için "." localhost ve (local) yazmanız aynı şeyler ifade eder.

localhostta yenii bir veritabanı oluşurmak için CMD  satırına localdb create veritabaniAdi yazmanız yeterli.
 Daha sonra Managment Sever Name alanına (local)\veritabaniAdi yazarak bağlanabilirisniz.
 
 
 
 
 
 --SELECT KOMUTU
select 3

select 3,5,7

select 'Oğuzhan'

print 'Dilek'

select * from Northwind.dbo.Personeller

select Adi, SoyAdi from Northwind.dbo.Personeller

--  ALIAS ATAMA
Select Adi Adı, SoyAdi Soyisimler from Northwind.dbo.Personeller

-- Boşluk Karakteri Olan Alias atama

select 1453 [İstanbulun Fethi]


-- Boşluk Karakteri Olan Tablo Sorgulama

select * from Northwind.dbo.[Satis Detaylari]

-- Kolonları Birleştirme

Select Adi+' '+ SoyAdi [İsim  ve Soyisimler]  from Northwind.dbo.Personeller

-- Farklı Tipte kolon Birleştirme

Select Adi+' '+ CONVERT(nvarchar,IseBaslamaTarihi) [İşe Başlama Tarihleri] from Northwind.dbo.Personeller

Select Adi+' '+ CAST(IseBaslamaTarihi as nvarchar) [İşe Başlangıç]  from Northwind.dbo.Personeller







USE Northwind

-- SELECT SORGULARıNDA (WHERE) ŞARTı YAZMAK

select * from dbo.Personeller

select * from dbo.Personeller where Sehir='London'

select * from dbo.Personeller where BagliCalistigiKisi<5

--And Operatörü
-- Personeller tablosunda şehri london ve ülkesi UK olanları listeleyelim.

select * from dbo.Personeller where Sehir='London' and Ulke='UK'

-- Or Operatörü
-- Personeller tablosunda UnvanEki 'MC.' olan veya şehri Seattle olan tüm personelleri listeleyelim.

select * from dbo.Personeller where UnvanEki='Mr.' or  Sehir='Seattle'

--Karşık Örnekler
--Adı Robert soyadı King olan personelin tüm bilgilerini çek.

select * from dbo.Personeller where Adi='Robert' and SoyAdi='King'

-- PersonellD'si 5 olan personeli getir.
select * from dbo.Personeller where PersonelID=5

-- PersonellD'si 5 'ten büyük olan tüm personelleri getir.

select * from dbo.Personeller where PersonelID>=5

-- <> Eşit Değilse
-- = Eşitse
-- <= Küçük ve Eşitse
-- >= Büyük ve Eşitse

-- Fonksiyon Sonuçlarını şart Olarak Kullanmak
--- 1993 yılında İşe başlayanları listele.

select * from dbo.Personeller where year(IseBaslamaTarihi)=1993

--- 1992 yılından sonra işe başlayanları listele.

select * from dbo.Personeller where YEAR(IseBaslamaTarihi)>1992

-- Doğum günü, ayın 29 olan personelleri listeleyelim.

select *from dbo.Personeller where Day(DogumTarihi)=29

--Doğum yılı 1950 ile 1965 yılları arasında olan personelleri getirelim.

select * from dbo.Personeller where YEAR(DogumTarihi)>1950 and YEAR(DogumTarihi)<1965

--- Yaşadığı şehrin Lcndon, Taccma ve Kirkland olan personellerin adını listeleyelim.

select Adi Adı from dbo.Personeller where Sehir='London' or Sehir='Kirkland' or sehir='Tacoma'

---Between Komutu
select * from dbo.Personeller where YEAR(DogumTarihi)>1950 and YEAR(DogumTarihi)<1965

select * from dbo.Personeller where YEAR(DogumTarihi) between 1950 and 1965

select * from dbo.Personeller where PersonelID between 2 and 5

--In Komutu

 select Adi İsimler from dbo.Personeller where Sehir='London' or Sehir='Tacoma' or Sehir='Kirkland'

 select Adi isimler from dbo.Personeller where Sehir in('London','Tacoma','Kirklanda')

 select Adi Adı, DogumTarihi [Doğum Tarihi] from  dbo.Personeller where YEAR(DogumTarihi) in(1948,1963)
 
 
 
 
 
 
 
 Use Northwind
 -- LIKE SORGULARı
-- % (Genel Önemli Değil) Operatörü

-- İsminin baş harfi j olan personellerin adını ve soyadını yazdıralım.

select Adi Adı, Soyadi Soyadı  from dbo.Personeller where Adi like('j%')

-- İsminin son harfi y olan personellerin adını ve soyadını yazdıralım.

select Adi İsim, SoyAdi Soyisim from dbo.Personeller where Adi like '%y'

--- İsminin son üç harfi ert olan personeli getirelim.

select Adi,Soyadi from dbo.Personeller where Adi like '%ert'

--- İsminin ilk harfi r, son harfi t olan personeli getirelim.

select Adi,Soyadi from dbo.Personeller where Adi like 'r%t'

-- Gereksiz bir kullanım.
select Adi,Soyadi from dbo.Personeller where Adi like 'r%' and Adi like'%t'

--- İsminde an geçen personelin adını yazdıralım.

select Adi,Soyadi from dbo.Personeller where Adi like '%an%'

--- İsminin baş harfi n olan ve İçerisinde an geçen personeli getirelim.

select Adi,Soyadi from dbo.Personeller where Adi like 'n%an%'

-- Gereksiz bir kullanım.

select Adi,Soyadi from dbo.Personeller where Adi like 'n%' and Adi like'%an%'



-- _(özel Onemli Değil) Operatörü

-- İsminin ilk harfi a, ikinci harfi fark etmez ve üçüncü harfi d olan personeli getirelim.

select * from dbo.Personeller where Adi like 'a_d%'

-- İsminin ilk harfi m, ikinci -üçüncü - dördüncü fark etmez ve beşinci harfi a olan personeli getirelim.

select * from dbo.Personeller where Adi like 'm___a%'

--[](ya da) Operatörü

-- İsminin ilk harfi n ya da m ya da r olan personelleri getirelim.

select * from dbo.Personeller where Adi like '[nmr]%'

-- İsminin İçerisinde a ya da İ geçen personelleri getirelim.

select * from dbo.Personeller where Adi like '%[ai]%'

-- [*-*] (Alfabetik Arasında) Operatörü

--- İsminin baş harfi a İle k arasında alfabetik sıraya göre herhangi bir harf olan personellerin adını yazdıralım.

select * from dbo.Personeller where Adi like '[a-k]%'


-- [^*] (Değil) Operatörü

--- İsminin baş harfi a olmayan personelleri getirelim.

select *from dbo.Personeller where Adi like '[^a]%'

--- İsminin baş harfi a ya da n olmayan personelleri getirelim.

select * from dbo.Personeller where Adi like '[^an]%'

-- Escape(Kaçış) Karakterleri
-- Like sorgularında kullandığımız %, _ , [] gibi özel ifadeler eğer ki verilerimiz içerisinde geçiyorsa sorgulama esnasında hata İle karşılaşabiliriz. Böyle durumlarda bu ifadelerin özel ifade olmadığını escape karakterleri İle belirleyebiliriz.
-- [] Operatörü İle
-- Escape Komutu İle

 select * from dbo.Personeller where Adi like '[_]%'

 select  Adi,Soyadi from dbo.Personeller where SoyAdi like 'n%%' escape 'n'
 
 select  Adi,Soyadi from dbo.Personeller where SoyAdi like 'n%%' escape 'n' --n kaçışın başlangıç alias gibi düşünebiliriz n den bir sonraki keyword değil demek 
 
 
 
 
 
 --AGGREGATE FONKSİYONLAR

-- AVG : Ortlama Alır

select AVG(PersonelID) PersonelIdOrtalamasi from .dbo.Personeller

select AVG(BirimFiyati) [Birim Fiyatı Ort] from dbo.[Satis Detaylari]

--MAX: En Büyük Değeri Bulur

select max(miktar) Miktar from dbo.[Satis Detaylari]

--MIN : En Küçük Değeri Bulur

select min(miktar) Miktar from dbo.[Satis Detaylari]

-- COUNT: Toplam kayıt Saysını Verir

select COUNT(*) from dbo.Personeller

select count(Adi) [Kayıt Sayısı] from dbo.Personeller

-- SUM: Toplamını Verir

select sum(nakliyeUcreti) nakliyeUcreti from dbo.[Satislar]







--STRING FONKSİYONLAR

-- LEFT :Soldan(baştan) belirtilen sayıda karakteri getirir.
Select Adi, LEFT(Adi,2) from dbo.Personeller

-- RİGHT : Sağdan(sondan) belirtilen sayıda karakteri getirir.

select Adi, RIGHT(Adi,2) from dbo.Personeller

-- UPPER :Büyük harfe çevirir.

select UPPER(Adi) from dbo.Personeller

select left(UPPER(Adi),3) from dbo.Personeller

-- UPPER :Büyük harfe çevirir.

select UPPER(SoyAdi) from dbo.Personeller

-- SUBSTRING : Belirtilen indexten itibaren belirtilen sayıda karakter getir.

select soyadi, SUBSTRING(SoyAdi,2,3) from dbo.Personeller

-- LTRIM :Soldan boşlukları keser.

select '       Oğuzhan'
select LTRIM('     Oğuzhan')

--- RTRIM : Sağdaki boşlukları keser.

select RTRIM('Zehra     ')

--- REVERSE :Tersine çevirir.

select REVERSE(Adi) from dbo.Personeller

--- REPLACE :Belirtilen ifadeyi, belirtilen ifade ile değiştirir.

select REPLACE('Merhaba ben Oğuzhan','Oğuzhan','Zehra') 

--CHARINDEX :Belirtilen karakterin veri içinde sıra numarasını verir.

select MusteriAdi, CHARINDEX('r',MusteriAdi) from dbo.Musteriler

-- CHARINDEX ornek
--- Müşteriler tablosunun MusteriAdi kolonundan sadece adlarını çekelim.

select MusteriAdi, SUBSTRING(MusteriAdi,0,CHARINDEX(' ',MusteriAdi)) [İlk Adı] from dbo.Musteriler

--- Müşteriler- tablosunun Muster•iAdi kolonundan sadece soyadlarını çekelim.

select MusteriAdi
,SUBSTRING(MusteriAdi
,CHARINDEX(' ',MusteriAdi)
,LEN(MusteriAdi)-(charindex(' ',MusteriAdi)-1)) 
from dbo.Musteriler





-- SAYıSAL DEĞER İŞLEMLERI

select 3 + 2
select 4-2
select 5*2 
select 10/2

--Pi sayısını verir.
select PI()

--- SIN : Sinüs alır.
select SIN(90)

-- POWER :Üs alır.
select power(2,3)

-- ABS : Mutlak değer alır.
select abs(-12)

--RAND: 0 - 1 arasında rastgele sayı üretir.
Select RAND()

-- FLOOR :Yuvarlama yapar.
select FLOOR(rand()*100)



-- Tarih Fonksiyonları
--- GETDATE :Bu günün tarihini verir.

select GETDATE()

-- DATEADD :Verilen tarihe verildiği kadar gün, ay, yıl ekler.

select DATEADD(day,999,getdate())

select DATEADD(month,99,getdate())

select DATEADD(year,9,'5.5.2009')

-- DATEDIFF : İki tarih arasında günü, ayı veya yılı hesaplar.

select DATEDIFF(day,'01.01.2025',getdate())
select DATEDIFF(day,'06.29.2015',getdate())

select DATEDIFF(month,'08.14.2021',getdate())

select DATEDIFF(year,'02.02.2024',GETDATE())

--- DATEPART :Verilen tarihin haftanın, ayın yahut yılın kaçıncı günü olduğunu hesaplar.

select DATEPART(DW,GETDATE()) --DW: Weekday

select DATEPART(month,getdate())

select DATEPART(day,getdate())

select DATEPART(year,getdate())




Use Northwind

--Top Komutu

select TOP 5 * from Personeller


--Distinct Komutu

select Sehir from Personeller

select DISTINCT Sehir from Personeller


--Group By Komutu

--Formulize edecek olursak: Normal kolon yanında Aggregate fonksiyon çağrılıyorsa normal kolon Group By ile gruplanır

select PersonelID, count(*) [Yaptığı Satış] from Satislar  GROUP BY PersonelID

select KategoriID,count(*) from Urunler group by KategoriID

select KategoriID,TedarikciID, count(*) from Urunler group by KategoriID,TedarikciID  --Birden fazla kolonu gruplama örneği

select * from Urunler

select * from Satislar

select PersonelID,SUM(NakliyeUcreti) [Toplam Nakilye Ucreti] from Satislar group by PersonelID

--- Group By işleminde Where Şartı Kullanma

select PersonelID, count(*) from Satislar where PersonelID>5 group by PersonelID

select * from Urunler

select UrunAdi, BirimFiyati, count(*) [50 TL ve Uzeri] from Urunler where BirimFiyati>=50 group by UrunAdi,BirimFiyati

---Group By İşleminde Having Komutu Kullanarak şart oluşturma
--Not: Where komutu ile arasındaki fark: Having aggregate fonksiyon için şart gerekirse yazılır ve groupby komutundan sonra gelir.

select PersonelID, count(*) [Toplam Kayıt] from Satislar where PersonelID>5 group by PersonelID having count(*)>70




-- Tabloları Yan Yana Birleştitme

Select * from Personeller
select * from Satislar

select * from Personeller, Satislar

select p.PersonelID, s.MusteriID from Personeller p , Satislar s

select p.PersonelID,s.PersonelID, count(*) [Toplam Kayıt] from Personeller p,Satislar s where p.PersonelID=s.PersonelID group by p.PersonelID,s.PersonelID

--Yukarıdaki birleştirme örneği ilkel bir yapıdadır. aşağıda Joinleri bu yapıyı baz alarak işleyip  avantajları veya dezavantajlarını inceleyeceğiz




--- Inner Join veya Join
--- Genel Mantık
--- Select * from Tablo1 Inner Join Tab1o2 on Tablo1.IliskiliKolon=Tablo2.IliskiliKolon
--- Tablolara alias tanımlanabilir.
--- Select * from Tablo1 t1 Inner Join Tablo2 t2 on t1.IliskiliKolon=t2.IliskiilKolon
--- İki Tabloyu İlişkisel Birleştirme
USE Northwind

--- Hangi personel hangi satışları yapmıştır.(Personeller,Satislar)

select * from Personeller
select * from Satislar

select p.Adi+' '+p.SoyAdi [Adı Soyadı], s.SevkAdi from Personeller p inner join Satislar s on p.PersonelID=s.PersonelID 

--Hangi ürün hangi kategoride. (Urunler, Kategoriler)

select u.UrunAdi, k.KategoriAdi from Urunler u inner join Kategoriler k on u.UrunID=k.KategoriID


--Inner Join'de Where Komutunun Kullanımı

--Beverages kategorisindeki ürünlerim. (Urunler, Kategoriler)

select * from Urunler u inner join Kategoriler k on u.UrunID=k.KategoriID where k.KategoriAdi='Beverages'

--Beverages kategorisindeki ürünlerimin sayısı kaçtır. (Urunler, Kategoriler)

select count(u.UrunAdi) Kayıt from Urunler u inner join Kategoriler k on u.UrunID=k.KategoriID where k.KategoriAdi='Beverages'

--Seafood kategorisindeki ürünlerin listesi (Urunler, Kategoriler)

select u.UrunAdi Urunler from Urunler u inner join Kategoriler k on u.UrunID=u.KategoriID where k.KategoriAdi='Seafood'

--Hangi satışı hangi çalışanım yapmış? (Satislar, Personeller)

select p.Adi+' '+p.SoyAdi [Adı Soyadı], s.SevkAdi from Satislar s inner join Personeller p  on s.PersonelID=p.PersonelID 

--Faks numarası 'null” olmayan tedarikcilerden alınmış ürünler nelerdir? (Urunler,Tedarikciler)

select u.UrunAdi,t.Faks from Urunler u inner join Tedarikciler t on u.TedarikciID=t.TedarikciID where t.Faks<>'Null'

select u.UrunAdi,t.Faks from Urunler u inner join Tedarikciler t on u.TedarikciID=t.TedarikciID where t.Faks is not null




-- - İkiden Fazla Tabloyu İlişkisel Birleştirme
--- 1997 yılından sonra Nancy nin satış yaptığı firmaların isimleri: (1997 dahil)(Müşteriler, Satislar, Personeller)

select p.Adi, m.SirketAdi from Personeller p inner join Satislar s on p.PersonelID=s.PersonelID inner join Musteriler m on m.MusteriID=s.MusteriID where p.Adi='Nancy' and  Year(s.SatisTarihi)>=1997

-- Limited olan tedarikçilerden alınmış seafood kategorisindeki ürünlerimin toplam satış tutarı. (Urunler , Kategoriler, Tedarikciler)

select Sum(u.BirimFiyati * u.HedefStokDuzeyi) [Toplam Satış Tutarı] from Kategoriler k inner join Urunler u on k.KategoriID=u.KategoriID inner join Tedarikciler t on t.TedarikciID=u.TedarikciID where k.KategoriAdi='Seafood' and t.SirketAdi Like '%Ltd.%'



-- - Aynı Tabloyu İlişkisel Olarak Birleştirme

-- Personellerimin bağlı olarak çalıştığı kişileri listele? (Personeller, Personeller)

select ast.Adi Ast, ust.Adi Ust from Personeller ust inner join Personeller ast on ust.PersonelID=ast.BagliCalistigiKisi


-- Inner Joinde Grup By

use Northwind
-- Hangi personelim(adl ve soyadı İle birlikte), toplam kaç adetlik satış yapmış. Satış adedi 100 den fazla olanlar ve personelin adının baş harfi M olan kayıtlar gelsin. (Personeller, Satislar)

select p.Adi+' '+p.SoyAdi [AdıSoyadı], count(s.SatisID) from Personeller p inner join Satislar s on p.PersonelID=s.PersonelID  where p.Adi like 'M%' group by p.Adi+' '+p.SoyAdi having COUNT(s.SatisID)>100 

--- Seafood kategorisindeki ürünlerin sayısı? (Urunler, Kategoriler)

select k.KategoriAdi, count(*) KayitSayisi from Kategoriler k inner join Urunler u on k.KategoriID=u.KategoriID where k.KategoriAdi='Seafood' group by k.KategoriAdi

-- Hangi personelim toplam kaç adet satış yapmış? (Personeller, Sati51ar)

select p.Adi+' '+p.SoyAdi [Adı Soyadı], count(*) [Sattığı Urun Adeti] from Personeller p inner join Satislar s on p.PersonelID=s.PersonelID group by p.Adi+' '+p.SoyAdi

--- En çok satış yapan personelim? (Personeller, Satislar)
select top 1 p.Adi, COUNT(*) from Personeller p inner join Satislar s on p.PersonelID=s.PersonelID group by p.Adi order by COUNT(*) desc

--- Adında "a” harfi olan personellerin satış id si 10500 den büyük olan satışlarının toplam tutarını(miktar*birimfiyat) ve bu satışların hangi tarihte gerçekleştiğini listele. (Personeller, Satislar, [Satİs Detaylari)

 select convert(nvarchar,day(s.SatisTarihi)) + '.' + convert(nvarchar,month(s.Satistarihi)) + '.' + convert(nvarchar,year(s.Satistarihi)) [Satış Tarihi], SUM(d.Miktar*d.BirimFiyati) [toplam Satış Tutarı] from Personeller p inner join Satislar s on p.PersonelID=s.PersonelID inner join [Satis Detaylari] d on s.SatisID=d.SatisID where p.Adi like '%a%' and s.SatisID>10500 group by s.SatisTarihi order by s.SatisTarihi asc




--Outer Join(Left,Right,Full) ile Tabloları Birleştirme 

use OrnekVT
INSERT INTO Filmler (Filmid, FilmAdi) VALUES
(1, 'GORA'),
(2, 'Lord Of The Rings'),
(3, 'Düğün Dernek'),
(4, 'Bir Zamanlar Anadolu''da'),
(5, 'Kurtlar Vadisi'),
(6, 'Recep İvedik'),
(7, 'Düğün Dernek'),
(8, 'Kahpe Bizans');

select * from Filmler

INSERT INTO Oyuncular (OyuncuId, Filmid, Adi, Soyadi) VALUES
(1, 1, 'Cem', 'Yılmaz'),
(2, 2, 'Muiddin', 'İmpatrino'),
(4, 2, 'Turgay', 'Arslaner'),
(5, 3, 'Gökhan', 'Aşker'),
(6, 4, 'Mustafa', 'Ağaoğlu'),
(7, 4, 'Mustafa', 'Güloğlu'),
(8, 5, 'Mustafa', 'Nuroğlu'),
(9, 5, 'M ust4', 'Bilmemneoğlu');

select * from Oyuncular


-- Inner Jcin'de eşleşen kayıtlar getiriliyordu. Outer Join 'de ise eşleşmeyen kayıtlarda getirilmektedir.


-- Left Join
-- Join ifadesinin solundaki tablodan tüm kayıtları getirir. Sağındaki tablodan eşleşenleri yan yana eşleşmeyenleri null olarak getirir.

select * from Filmler f left outer join Oyuncular o on f.FilmId=o.FilmID
select * from Oyuncular o left outer join Filmler f on o.FilmID=f.FilmId

-- veya

select * from Oyuncular o left join Filmler f on o.FilmID=f.FilmId
select *from Filmler f left join Oyuncular o on f.FilmId=o.FilmID

--Not : outer keyword'ü eskiden kullanılıyordu. Güncel olarak kullanılmasına gerek yok dolayısyla aşağıdaki komutlarda outer keyword'ü yazılmayacak.

--- Right Join
-- Joinin sağındaki tablonun tamamını getirecek, solundakinden eşleşenleri aynı satırda eşleşmeyenleri de null olarak getirecek.

select * from Oyuncular o right join Filmler f on o.FilmID=f.FilmId
select* from Filmler f right join  Oyuncular o on o.FilmID=f.FilmId


-- Full Join
--- Joinin iki tarafındaki tablolardan eşleşen eşleşmeyen hepsini getirir.
select * from Oyuncular o full join Filmler f on o.FilmID=f.FilmId

select * from Filmler f full join Oyuncular o on o.FilmID=f.FilmId





--Cross Join 
-- Cross Join iki tablo arasında kartezyen çarpım sağlar ve sonucu tablo olarqak döndürür.
--Aşağıdaki örnekte iki farklı tabloyu cross join ile birleştireceğiz. Doğru birleşmenin sağlamasını iki tablonun eleman saysının çarpımı ile doğrulancakatır. Örnek: Personeller Count = 9 Bölge Count =4 9*4=36 adet sonuç döndürmesi gerekiyor.
use Northwind
select count(*) from Personeller 
select count(*) from Bolge

select p.Adi,b.BolgeID from Personeller p cross join Bolge b

--Not:
--1) Diğer Join komutlarında olduğu gibi ON keyword'ünü kullanmayız. Çünkü kartezyen çarpım ile bütün eşleşmeleri yapıyor.
--2) Where keyword2ü ile herhangi bir şartta bağlanamaz.

--Örnek :
--10 öğrenci adayı var ✅

--9 farklı temin tipi var ✅

--Her öğrenci adayı her temin tipini seçebilir (tüm kombinasyonlar gerekir) ✅

--Yani:

--Her öğrenci 9 temin tipinden birini seçebileceği gibi hepsiyle eşleşmesi de ihtimal dahilinde.
--Sonuç: 10 × 9 = 90 satır




-----DML KOMUTLARINA GİRİŞ----

--DML (Data Manipulation Language)
---- Select, insert, Update, Delete
--- Select...
--- insert ...
--- Update ...
--- Delete ...

USE Northwind

--Select 
Select * from Personeller


--Insert 
-- Insert [Tablo Adı] (Kolonlar) Values(Değerler)

--Kolon adı belirterek ekleme
insert  Personeller(Adi,SoyAdi) values('Oğuzhan','Dilek') --Kolon adları ile göndereceğiniz values'ler aynı ırada olamalıdır.

--Tüm Kolonlara veri ekleme

insert Personeller values('Dilek','Zehra','Tatlı Bebek','Immm','01.01.2024',GETDATE(),'Ankara','Erzurum','İçAnadolu','0600','Turkiye',null,null,null,null,null,null)


--- [Dikkat Edilmesi Gerekenler! ! ! ]
--- Into Komutu İle Yazılabilir
insert into Personeller(SoyAdi,Adi) values('Dilek','Sutlaç')
--- Kolonun kabul ettiği veri tipi ve karakter uzunluğunda kayıt yapılmalıdır.
--- Not NuII olan kolonlara boş bırakılamayacaklarından dolayı mutlaka değer gönderilmelidir.
insert Personeller(Unvan,UnvanEki) values ('Doktor','Prof.')

-- Otomatik artan(İdentİty) kolonlara değer gönderilmez.
-- Tablodaki seçilen yahut bütün kolonlara değer gönderileceği belirtilip, gönderilmezse hata verecektir.

insert Personeller(Adi,SoyAdi) values('Dilek')
insert Personeller values('Dilek')

---[Pratik Kullanım]
insert Personeller(Adi,Soyadi) values ('Sulhettin','Kebap')
insert Personeller(Adi,Soyadi) values ('Murtaza','Yanbakan')
insert Personeller(Adi,Soyadi) values ('Mugıme','Düzayak')

insert Personeller(Adi,SoyAdi) values ('Sulhettin','Kebap'),
	('Murtaza','Yanbakan'),
	('Mugıme','Düzayak')
	
	
	
--- [insert Komutu İle Select Sorgusu Sonucu Gelen Verileri Farklı Tabloya Kaydetme]
select * from OrnekPersoneller
insert OrnekPersoneller select Adi,Soyadi from Personeller
-- Burada dikkat etmeniz gereken nokta; Select sorgusunda donen kolon sayısı İle insert İşlemi yapılacak tablonun;
-- 1) kolon sayısı birbirine eşit olması 
-- 2) tiplerinin aynı olması
-- 3) Kolon Sırasının aynı olması gerekmektedir.
-- 4) Kolon isimlerinin dahi aynı olamsı lazım


-- [Select Sorgusu Sonucu Gelen Verileri Farklı Bir Tablo Oluşturarak Kaydetme]
 select Adi,Soyadi,Ulke into OrnekPersoneller2 from Personeller
 select * from OrnekPersoneller2
--- Bu yöntemle primary key ve foreign keyler oluşturulamazlar.



--- Update
--- Update [Tablo Adı] Set [Kolon Adı] = Değer

use Northwind

update OrnekPersoneller set Adi='Ülkü' where Adi='Zehra' --Eğer where şartı konulmazsa bütün kolunun hepsini set edilen değer ile günceller
select * from OrnekPersoneller

--- [Update Sorgusunda Join Yapılarını Kullanarak Birden Fazla Tabloda Güncelleme Yapmak]
select * from OrnekPersoneller
--Personeller tablsounda 12 ID'li personelin soyadını  OrnekPersoneller tablsonudaki Adı kolnuyla güncelle
update OrnekPersoneller set Adi= p.SoyAdi from Personeller p inner join OrnekPersoneller o on p.PersonelID=o.PersonelId where p.PersonelID=12

--- [Update Sorgusunda Subquery İle Güncelleme Yapmak)

Update OrnekPersoneller set Soyadi=(Select Adi from Personeller where PersonelID=3) where OrnekPersoneller.Adi='Janet'

--- [Update Sorgusunda Top Keywordü İle Güncelleme Yapmak]

update top (3) OrnekPersoneller set SoyAdi=null


--- Delete
--- Delete from [Tablo Adı ]

--[Delete Sorgusuna Where Şartl Yazmak]


Delete From OrnekPersoneller where PersonelId<=3
select * from OrnekPersoneller
--- [Dikkat Edilmesi Gerekenler! ! ! ]
-- Delete sorgusuyla tablo içerisindeki tüm verileri silmeniz identity kolonunu sıfrlamayacaktır. Silme işleminden sonra İlk eklenen veride kalındığı yerden id değeri verilecektir.
delete from OrnekPersoneller where Adi in ('Zehra')



-- Union | Unİon All
--- Union Komutu
--- Birden fazla select sorgusu sonucunu tek seferde alt alta göstermemizi sağlar.

---Aiaşıdaki senaryoda Musteriler tablosundaki ad soyadları alıp SınıfA , Personeller Tablosundaki  ad soyadları alıp SınıfB Tabloları oluşturlacak ve bunları Union ile birleştirip alt alat sıralama yapacağız. bu şeilde Okuladki tüm öğrenci listesi çıkmış olacak

select SUBSTRING(MusteriAdi,0,CHARINDEX(' ',MusteriAdi)) [Adi],SUBSTRING(MusteriAdi,CHARINDEX(' ',MusteriAdi),LEN(MusteriAdi)-(charindex(' ',MusteriAdi)-1))[SoyAdi]  into SinifB from Musteriler

select PersonelID,SoyAdi,Adi into SinifA from Personeller


Select  Adi,SoyAdi from SinifA
Union
Select Adi,SoyAdi from SinifB

--- 2 'den fazla
Select  Adi,SoyAdi from SinifA
Union
Select Adi,SoyAdi from SinifB
Union
Select Adi,SoyAdi from Personeller

--Joinler yan yana, Union alt alta tabloları birleştirir. Joinlerde belirli(ilişkisel) bir kolon üzerinden birleştirme yapılırken, Union 'da böyle bir durum yoktur.

--- Dikkat etmemiz gereken koşullar;
-- Union sorgusunun sonucunda oluşan tablonun kolon isimleri, üstteki sorgunun kolon İsimlerinden oluşturulur.
--- Üstteki sorgudan kaç kolon çekilmişse alttaki sorgudan da o kadar çekilmek zorundadır.
-- Üstteki sorgudan çekilen kolonların tipleriyle, alttaki sorgudan çekilen kolonların tipleri uyumlu olmalıdır.
--- Union tekrarlı kayıtları getirmez.
-- Union'da kullanılan tablolara kolon eklenebilir. Dikkat etmemiz gereken nokta, yukarıdaki kurallar çerçevesinde aşağıyada yukarıyada aynı sayıda kolonların eklenmesi gerekmektedir.


Select  Adi,SoyAdi,'A Sınıfı' from SinifA
Union
Select Adi,SoyAdi,'B Sınıfı' from SinifB

-- Union ALL
--- Union tekrarlı kayıtları getirmez. Tekrarlı kayıtları getirmek için Union All Komutu kullanılmalıdır.

Select  Adi,SoyAdi from SinifA
Union All
Select Adi,SoyAdi from SinifA




-- With Rollup | Wtith Cube

-- With Rollup Group By ile gruplanmış veri kümesinde ara toplam alınmasını sağlar.

Select Sehir,Urun,Sum(SatisMiktari) from Satislar group by Sehir,Urun with rollup
 --Sadece şehir bazlı toplamlar + genel toplam var.

 --- [Having Şartıyla Beraber With Rollup]
 Select Sehir,Urun,Sum(SatisMiktari) from Satislar group by Sehir,Urun with rollup having sum(SatisMiktari)>10
 
 
 --With Cube Tüm grupların tüm olası kombinasyonlarının toplamlarını verir.

 Select Sehir,Urun,Sum(SatisMiktari) from Satislar group by Sehir,Urun with cube
 --👉 Hem şehir hem ürün bazlı toplamlar + genel toplam var.

  --- [Having Şartıyla Beraber With Cube]
 Select Sehir,Urun,Sum(SatisMiktari) from Satislar group by Sehir,Urun with cube having sum(SatisMiktari)>10



-- Case - When- Else — End
-- Personellerimizin isim ve soyisimlerinin yanında; UnvanEki 'Mr'İse  Erkek, 'Ms.' ve'Mrs.' ise Kadın  yazsın.

select Adi,SoyAdi,
Case
When UnvanEki='Mrs.' or Unvaneki='Ms.' Then 'Kadın'
When UnvanEki='Mr.' Then 'Erkek'
Else UnvanEki
End
from Personeller

--- Eğer ürünün birim fiyatı 0-50 arası İse 'Çin Malı',	50 -100 arası İse 'Ucuz',	100-200 arası İse 'Normal' ve 200' den fazla İse 'Pahalı' yazsın.

select UrunAdi,
Case
When BirimFiyati>0 and BirimFiyati<50 Then 'Çin Malı'
When BirimFiyati between 50 and 100 Then 'Ucuz'
When BirimFiyati between 100 and 200 Then 'Normal'
When BirimFiyati>200 Then 'Pahalı'
Else 'Belirsiz'
End
from Urunler

--Yukarıdaki örnekte bir filtre yapmak istersek o zamanda SubQuery yönremini kullanırdık Yani;

select * from (select UrunAdi,
Case
When BirimFiyati>0 and BirimFiyati<50 Then 'Çin Malı'
When BirimFiyati between 50 and 100 Then 'Ucuz'
When BirimFiyati between 100 and 200 Then 'Normal'
When BirimFiyati>200 Then 'Pahalı'
Else 'Belirsiz'
End as FiyatGrubu
from Urunler) as UrunEtiketli
where FiyatGrubu='Çin Malı'


--With Ties Komutu
-- Bu komut TOP komutu ile birlikte kullananılabilir. amacı Belli sayıda bir sıralama yaparken örneğin  ilk 6 kaydı getirmek istediğimizde 6. kayıta eş değer bir veri varsa onları getirmeyi sağlar. Mesala bir yarışmada ilk 3 kişi belirleriz ancak 3. kişi ilede aynı puanı almış yarışmacılar olabilir. İşte böyle bir istisna durumda with ties komuut bize yardımcı olacaktır.

--With Ties komutu kullanıyorsan sorgunun sonunda ORDER BY'da kullanmak zorundasın

Select * from [Satis Detaylari]

select top 6 with ties * from [Satis Detaylari] order by SatisID

 
--With Komutu

-- WITH komutu (CTE - Common Table Expression),
-- karmaşık sorguları daha okunabilir hale getirmek için kullanılır.
-- Geçici bir sonuç kümesi oluşturur ve bu küme, sorgunun devamında sanki bir tablo gibi davranır.
-- Tek bir kez tanımlanır ve birden fazla kez kullanılabilir (sorgu içinde).
-- Alt sorgulara göre daha temiz ve modüler bir yapı sunar.


With PersonelSatis(id,adi,soyadi,satisId)
as 
(
select p.PersonelID,p.Adi,p.SoyAdi,s.SatisID from Personeller p inner join Satislar s on p.PersonelID=s.PersonelID
)

--select * from PersonelSatis

select * from PersonelSatis ps inner join [Satis Detaylari] sd on ps.satisId=sd.SatisID


--- Subquery (iç içe Sorgular)
-- Önemli Uyarı: Subquery'ile dönen verinin tek satırda olamsı gerekmektedir eğer birden fazla satır dönerse subquey çalışmayacaktır.

select s.SatisTarihi,s.SatisID from Personeller p inner join Satislar s on p.PersonelID=s.PersonelID where p.Adi='Nancy'
 
 select s.SatisTarihi,s.SatisID from Satislar s where s.PersonelID=(select p.PersonelID  from Personeller p where p.Adi='Nancy')
 
 
 
 --- Bulk insert
 
 --Kisiler.txt
 -- Ad	Soyad	Unvan
-- Oğuzhan	Dilek	Full Stack Dev.
-- Zehra	Dilek	Bebiş
-- Sütlaç	Dilek	Pişo

bulk insert Kisiler from 'D:\personal-repo\T-SQL-DERSLER-\Kisiler.txt'
with
(
Fieldterminator='\t',
RowTerminator='\n'
)

select * from Kisiler


--Truncate Komutu

--__Identity kolonunu sıfırlar
--Test yapıldıktan sonra proje Publish edilemeden önce test verilerini sıfırlamak için kullanılabilir.

select * into PersonellerX from Personeller

truncate table PersonellerX


--@@Identity Komuutu

--Son yapılan Insert işleminin Identity değerini bir tabloda getirir

Insert into Kategoriler(KategoriAdi,Tanimi) values ('X','X Kategorisi')

select @@IDENTITY

Insert Personeller(Adi,SoyAdi) values('Husam','Candar')

--@@ROWCOUNT Komutu

--Herhangi bir işlemde (Select, Insert, Update vs) etkilenen kaç değer varsa onu döndürür

Delete from PersonellerX where Adi='Husam'
Select @@ROWCOUNT

Select * from Personeller
select @@ROWCOUNT

Insert PersonellerX(Adi,Soyadi) Values('Adam','Smith'),
										('Muhit','SS')
										select @@ROWCOUNT
										


--Identity Kolonuna Müdahale etme
--Önmeli Uyarı Son İdentity değerinde daha yükesk bir değer girlmesi gerekir
DBCC Checkident(PersonellerX,reseed,27)




--NULL Kontrol Mekanizmaları

-- Bu mekanizmaları null değerleri olan bir tabloda rapor hazırlarken kullanırız.

-- Case-Hhen-Then-E1se-End Kalıbı İle Null Kontrolü

Select MusteriAdi, Bolge, 
Case
When Bolge IS NULL then 'Bölge Bilinmiyor'
else
Bolge
End
 from Musteriler

 ---- Coalesce Fonksiyonu İle Null Kontrolü

 select MusteriAdi, coalesce(Bolge,'Bölge Bilinmiyor')  from Musteriler
--Null Kontrolü yapılcak olan kolonun tipi ne ise ikinci parametrede o itpte olmalıdır.

 -- IsNull Fonksiyonu İle Null Kontrolü

 select MusteriAdi, isnull(Bolge,'Bolge Bilinmiyor') from Musteriler
 --Null Kontrolü yapılcak olan kolonun tipi ne ise ikinci parametrede o itpte olmalıdır.

 -- NullIf Fonksiyonu İle Null Kontrolü
-- Fonksiyona verilen kolon, İkinci parametre verilen değere eşit İse o kolonu Null olarak getirir.

select nullif(1,2);
select nullif(0,0);

Select HedefStokDuzeyi from Urunler
Select AVG(HedefStokDuzeyi) from Urunler

--- Hedef stok düzeyi O olmayan ürünlerin ortalaması nedir?
Select AVG(HedefStokDuzeyi) from Urunler where HedefStokDuzeyi<>0
select AVG(nullif(HedefStokDuzeyi,0)) from Urunler 

--ONEMLİ RAPORLARDA KESİNİLKLE NULL DEĞERLERİ BOŞ BIRAKMAYIN!!'NULLIFF ile veya diğer fonksiyonlarla bir şekilde belli edin yada hesaptan çıkarılamsını sağlayın. Aksi halde yanlış hesap çarşıdan döner


--- T -SQL ile Veritabanındaki Tabloları Listeleme

select * from sys.tables

--ya da

Select * from sysobjects where xtype='u'


--- Bir Tablonun Primary Key Olup Olmadığını Kontrol Etme

Select OBJECTPROPERTY(OBJECT_ID('Personeller'),'TableHasPrimaryKey')

-- Eğer sonuç 1 değerini döndürüyrsa o zman tabloda primary key mevcuttur.








--DDl (Data Definition Language)
--- T-SQL de veritabanı nesneleri oluşturmamızı sağlayan ve bu nesneler üzerinde değişiklikler yapnamızı ve silmenizi sağlayan yapılar bu başlık altında simgelenmektedir.
-- Create, Alter, Drop 

- ---CREATE---
-- Veritabanı nesnesi oluşturmamızı sağlar.(database,table,view,storedproc,trigger vs.)
-- Prototipi
--Create [Nesne] [Nesnenin Adi]
-- —Create İle Database Oluşturma

Create Database OrnekVeriTabani

--- Bu şekilde bir kullanım varsayılan ayarlarda veritabanı oluşturacaktır.

Create Database OrnekVeriTabani
on
(
	Name='GG',
	Filename='D:\GG.mdf',
	Size=5,
	Filegrowth=3
)
-- Name : Oluşturulacak veritabanının fiziksel ismini belirtiyoruz.
--- Filename : Oluşturulacak veritabanı dosyasının fiziksel dizinini belirtiyoruz.
--- Size : Veritabanının başlangıç boyutunu mb cinsinden ayarlıyoruz.
--- Filegrowth : Veritabanının boyutu, başlangıç boyutunu geçtiği durumda boyutun ne kadar artması gerektiğini mb cinsinden belirtiyoruz.


-- —Create İle Log Dosyasıyla Birlikte Database Oluşturma

Create Database OrnekVeriTabani
on
(
	Name='GG',
	Filename='D:\GG.mdf',
	Size=5,
	Filegrowth=3
)
Log
on
(
	Name='GG_LOG',
	Filename='D:\GG.ldf',
	Size=5,
	Filegrowth=3
)

-- —Create İle Tablo Oluşturma
USE OrnekVeriTabani

Create Table tablo1
(
	Kolon1 int,
	Kolon2 nvarchar(max),
	Kolon3 money
)

--- Eğer kolon adlarında boşluk varsa köşeli parantez ile belirtilmelidir.

Create table tablo2
(
	[Kolon 1] int,
	[Kolon 2] nvarchar(50),
	[Kolon 3] money
)

--- —Kolona Primary Key ve Identity özelliği Kazandırmak

create table Tablo3
(
	Id int Primary key Identity (1,1),
	Kolon2 nvarchar(20)
)



---ALTER-----
-- Create ile oluşturulan veritabanı nesnelerinde değişiklik yapmamızı sağlar.
-- Prototip
-- Alter [Nesne] [Nesnenin Adi]
-- (Yapıya Göre İşlemler)

-- —Alter İle Database Güncelleme

Alter Database OrnekVeriTabani
Modify File
(
	Name='GG', --Name' i GG olan veritabanına göre işem ayapar aslında burada bir where var
	Size=20
)

--- —Alter İle Olan Bir- Tablo 8 Kolon Ekleme

Alter Table tablo1
Add Kolon5 nvarchar(max)


--- Alter- İle Tablodaki Kolonu Güncelleme
Alter table tablo1
Alter Column Kolon4 int
--Not kolonda veri olmaması gerkiyor

-- —Alter İle Tablodaki Kolonu Silme
Alter Table tablo1
Drop Column Kolon4

-- —Alter İle Tabloya Constraint Ekleme

Alter Table tablo1
Add Constraint OrnekConstraint Default 'boş' for Kolon2

-- —Alter İle Tabloya Constraint Silme

Alter Table tablo1
Drop Constraint OrnekConstraint 



-- SP_RENAME ile tablo adı Güncelleme

SP_RENAME 'tablo1','OrnekTablo'


-- SP_RENAME ile Kolon adı  Güncelleme

SP_RENAME 'OrnekTablo.Kolon1','Id','Column'

-- Create İle oluşturulan veri tabanı nesnelerini silmemize yarar.
-- Prototip
--- Drop [Nesne] [Nesne Adı]
Drop table OrnekTablo
Drop Database OrnekVeriTabani





-- Constraintler (Kısıtlayıcılar)
-- Constraintler sayesinde tablolar üzerinde istediğimiz şartlar ve durumlara göre kısıtlamalar yapabiliyoruz.
--DEFAULT CONSTRAINT
--CHECK CONSTRAINT
--PRİMARY KEY CONSTRAINT
--UNIQUE COUSTRAINT
--FOREIGN KEY CONSTRAINT 


--- DEFAULT CONSTRAINT
--- Default Constraİnt sayesinde kolona bir değer girilmediği taktirde varsayılan olarak ne girilmesi gerektiğini belirtebiliyoruz.
---- Genel Yapısı;
--- Add Constraint [Constraint Adı ] Default 'Varsayılan Değer' For [Kolon Adı]

create table OrnekTablo
(
Id int primary key identity(1,1),
Kolon1 nvarchar(max),
Kolon2 int
)

Alter Table OrnekTablo
Add Constraint Kolon1Constraint Default 'Bilgi Yok' For Kolon1

Alter Table OrnekTablo
Add Constraint Kolon2Constraint Default -1 For Kolon2


insert OrnekTablo(Kolon2) values(0)
insert OrnekTablo(Kolon1) values('Örnek bir değer')

select * from OrnekTablo


--CHECK CONSTRAİNT
-- Bir kolona girilecek olan verinin belirli bir şarta uymasını zorunlu tutar.
--- Genel Yapısı;
-- Add Constraint [Constraint Adı] Check (ŞART)

Alter table OrnekTablo
Add Constraint Kolon2Kontrol Check ((Kolon2*5)%2=0)

-- Check ccnstraint oluşturulmadan önce ilgili tabloda şarta aykırı değerler varsa eğer	constraint oluşturulmayacaktır !
-- Ancak önceki kayıtları görmezden gelip genede Check Constraintİ uygulamak İstiyorsak	"Wİth Nocheck" komutu kullanılmalıdır.
-- Wİth Nocheck Komutu
--- Şuana kadar olan kayıtları görmezden gelip, check constrainti uygulattırır.

Alter table OrnekTablo
--Drop Constraint Kolon2Kontrol
With Nocheck Add Constraint Kolon2Kontrol Check ((Kolon2*5)%2=0)

---PRIMARY KEY CONSTRAINT
--- Primary Key Constraint ile; o kolona eklenen primary key ile, başka tablolarda foreign key oluşturarak ilişki kurmamız mümkün olur.
--Bunun yanında o kolonun taşıdığı verinin tekil olacağı da garanti edilmiş olur. Primary key constraint İle ayrıca CLUSTERED index oluşturulmuş da olur.
---- Genel Yapısı;
--- Add Constraint [Constraint Adı] Primary Key (Kolon Adı)

--DİKKAT!!!
-- Primary Key Constraint kullanılan kolon primary key özelliğine sahip olmamalıdır.

Alter table Ornektablo
Add Constraint PrimaryId Primary key (Id)


-- UNIQUE CONSTRAINT
-- Unique constraintin tek amacı, belirttiğimiz kolondaki değerlerin tekil olmasını sağlamaktır.
-- Genel Yapısı;
--- Add Constraİnt [Constraİnt Adı] Unique (Kolon Adı)

Alter table Ornektablo
Add Constraint OrnekTabloUnique Unique (Kolon2)
--"Kolon2" kolonuna unique constraint verilerek tekil hale getirilmiştir. Bundan sonra ikitane aynı veriden kayıt yapılamamaktadır.

--- FOREIGN KEY CONSTRAINT
-- Tabloların kolonları arasında ilişki kurmamızı sağlar. Bu ilişki neticesinde; foreign key olan kolondaki karşılığının boşa düşmemesi İçin primary key kolonu olan tablodan veri silinmesini, güncellenmesini engeller.
-- Genel Yapısı;
--- Add Constraint [Constraint Adı] Foreign Key (Kolon Adı) References [2. Tablo Adı] (2. Tablodaki Kolon Adı)


create table Ogrenciler
(
OgrenciId int primary key identity(1,10),
DersId int,
Adi nvarchar(50),
Soyadi nvarchar(50)
)
create table Dersler
(
DersId int primary key identity(1,1),
DersAdi nvarchar(50)
)

Alter table Ogrenciler
Add Constraint ForeignKeyOgrenciDers Foreign key (DersId) References Dersler(DersId)

--- Şu durumda, delete ve update İşlemlerinden İlişkili kolondaki veriler etkilenmez.
-- Davranışı değiştirmek için aşağıdaki komutlar kullanılır.

--- -Cascade
---- Ana tablodaki kayıt silindiğinde ya da güncellendiğinde, İlişkili kolondaki karşılığıda otomatik olarak silinir ya da güncellenir.

Alter Table Ogrenciler
Add Constraint ForeingKeyOgrenciDers Foreign Key (DersId) References Dersler(DersId)
ON DELETE CASCADE
ON UPDATE CASCADE

--- —Set Null
---- Ana tablodaki kayıt silindiğinde ya da güncellendiğinde, ilişkili kolondaki karşılığına "Null" değer basılır.
Alter table Ogrenciler
add Constraint ForeignKeyOgrenciDers  Foreign Key (DersId) References Dersler(DersId)
ON Delete Set Null
ON Update Set Null

--- -Set Default
---- Ana tablodaki kayıt silindiğinde ya da güncellendiğinde, ilişkili kolondaki karşılığına o kolonun default değeri basılır. Bu default değer dediğimiz default tipte bir constrainttir. Bunu kendimiz oluşturabiliriz.

Alter Table Ogrenciler
Add Constraint SetDefaultConstraint Default -1 For DersId

Alter Table Ogrenciler
Add Constraint ForeignKeyOgrenciDers Foreign key (DersId) References Dersler(DersId)
On Delete Set Default
On Update Set Default

--Dikkat !! Default değer aana tablodaki kaynağa göre olamlıdır . yukarıdaki örnekte Dersıd içinde -1 değeri bulunmadığı için hata verecektir.

---- Bu ayarlar verilmediği taktirde "no action" özelliği geçerlidir.




--Değişkenler
-- Declare keywordü İle Değişken tanımlanır.
-- Prototip;
--- Declare @DegiskenAdi DegiskenTipi

declare @x int

declare @y nvarchar(50)

declare @z money

declare @x int, @y money, @z bit

declare @Yas int=3


-- Tanımlanmış Değişkenlere Değer Atama

declare @Adi nvarchar(50)='Zehra'

declare @x int

--SET

Set @x=125

declare @tarih datetime

Set @tarih=GETDATE()


-- Değişken Değeri Okuma

declare @x int
set @x=3
select @x
print @x

--Sorgu Sonucu Gelen Verileri Değişkenle Elde Etme

declare @Adi nvarchar(max), @Soyadi nvarchar(max)
Select @Adi=Adi,@Soyadi=SoyAdi  from Personeller where  PersonelID=1
Print @Adi+ ' ' + @Soyadi
-- 1. Sorgu sonucu gelen satır sayısı bir adet olmalıdır.
-- 2. Kolonlardaki verilerin tipleri ne ise c verileri temsil edecek değişkenlerin tipleride benzer olmalıdır.






--Batch Kavramı - Go
-- yazılan kodları farklı iş parcçacıklarına ayrıldığını compailer'a ifade eden keyworddür.

Create Database OrnekDatabase
Use OrnekDataBase
Create Table OrnekTable
(
 Id int primary key identity (1,1),
 Adi nvarchar(max),
 Soyadi nvarchar(max)
)

Insert Into OrnekTable Values('Oğuzhan','Dilek')
Select * from OrnekTable





--IF Yapısı

-- = : Eşitse
-- <> : Eşit Değilse
-- > : Büyüktür
-- < : Küçüktür

--Tek Satırlık Çalışma

Declare @Isim nvarchar(max)
Set @Isim='Dilek'

if @Isim='Dilek'
	print 'Evet'
Else
	Print 'Hayır'

-- Begin-End Yapısı (Scope)
--Koşu sonucu birden fazla işlem yapılacaksa Begin_end ile scoplanır.
declare @Sayi1 int=2, @Sayi2 int=5

if @Sayi1> @Sayi2
	Begin
		print 'Evet Sayı1 Sayı2 den Büyüktür'
		select @Sayi1 [Sayı 1], @Sayi2 [Sayı 2]
	End
Else
	Begin
		print 'Hayır Sayı1 Sayı2 den küçüktür'
		select @Sayi1 [Sayı 1], @Sayi2 [Sayı 2]
	End

--Örnek 1
--- Müşteriler tablosunda Amerikalı (USA) müşteri var mı?
Use Northwind
select * from Musteriler where Ulke='USA'
if @@ROWCOUNT>0 
	print 'Evet'
Else
	Print 'Hayır'

---- Örnek 2
--- Adı 'Oğuzhan'
--soyadı 'Dilek' olan Personel var mı? Varsa evet var desin. Yoksa kaydetsin.

Use Northwind
Declare @adi nvarchar(max)='Rumeysa', @soyadi nvarchar(max)='Dilek'
Select * from Personeller where Adi=@adi and SoyAdi=@soyadi
if @@ROWCOUNT>0
	print 'Evet Var'
Else
	Begin
	insert into Personeller(Adi,Soyadi) values(@adi,@soyadi)
	print 'hayır yok ama eklendi'
	End

--- If-Else If- Else Yapısı

declare @adi nvarchar(max)='Oğuzhan', @Yas int=33

if @adi='Mahmut'
	print 'evet'
Else if @Yas>24
	print 'Evet yaşı 24-ten büyük'
Else
	print 'hayır'



-- Exists Fonksiyonu
--Sorgu sonucu tablonun dolu mu boş mu olduğunu döndüren fonksiyondur

if Exists(Select * from Personeller)
	print 'True'
Else 
	Print 'False'
	

--While Döngüsü

-- While Şart Komutu

declare @sayi int =0

while @sayi<=100
	Begin
		print @sayi
		set @sayi=@sayi+1
	End


--While Döngüsü

-- Break Komutu

declare @sayi int =0

while @sayi<=100
	Begin
		print @sayi
		set @sayi=@sayi+1
		if @sayi%5=0
		break
	End
	
	--While Döngüsü

-- Contiune Komutu

declare @sayi int =0

while @sayi<=100
	Begin
		if @sayi%5=0
			begin
				set @sayi=@sayi+1
				continue
		end
		print @sayi
		set @sayi=@sayi+1
	
	End
	
	
	
--- Geçici Tablolar - Temporary Tables

-- Genellikle bir SQL Server üzerinde farklı lokasyonlarda birden fazla kişinin çalıştığı durumlarda ya da verilerin test amaçlı geçici bir yerlerde tutulması, işlenmesi amacıyla kullanılan yapılardır.
--- Bilinen tablo yapısının aynısını sağlarlar. Tek farkları fiziksel olarak oluşmazlar. Sadece bellekte geçici olarak oluşturulurlar.
--- Select, insert, Update ve Delete işlemleri yapılabilir. İlişki kurulabilir.
-- Sunucu kapatıldığında ya da oturum sahibi oturumu kapattığında bellekten silinirler.


--- #Bir Tabloyu Fiziksel Olarak Kopyalama

Select * Into GeciciPersoneller from Personeller
--- Bu şekilde bir kullanımda sadece primary key ve foreign key constraintler oluşturulmazlar. Geri kalan herşey birebir fiziksel olarak oluşturulur.

--- *Bir Tabloyu # İfadesi İle Belleğe Geçici Olarak Kopyalama

select * into #GeciciPersoneller from Personeller

select * from #GeciciPersoneller
insert into #GeciciPersoneller(Adi,SoyAdi) values('Deli','Dolu')
Delete #GeciciPersoneller where Adi='Deli'
Update #GeciciPersoneller set SoyAdi='Manyak' where Adi='Oğuzhan'

--- Geçici tablo üzerinde her türlü işlemi yapabiliyoruz I
---- # ile oluşturulan tablo, o an SQL Serverda oturum açmış kişinin sunucu belleğinde oluşur.
--- Sadece oturum açan şahıs kullanabilir.
--- Eğer oturum açan şahıs SQL Servardan disccnnet olursa bu tablo bellekten silinir.



-- *Bir Tabloyu ## İfadesi İle Belleğe Geçici Olarak Kopyalama

select * into ##GeciciPersoneller from Personeller

insert into  ##GeciciPersoneller(Adi,SoyAdi) values('Deli','Dolu')
Delete ##GeciciPersoneller where Adi='Deli'
Update ##GeciciPersoneller set SoyAdi='Manyak' where Adi='Oğuzhan'
select * from ##GeciciPersoneller

--- ## ile oluşturulan tablo, o an SQL Servarda oturum açmış kişinin sunucu belleğinde oluşur.
---- Bu tabloyu oturum açan şahıs ve onun SQL Servarına dışardan ulaşan 3. şahıslar kullanabilir.
--- Eğer oturum açan şahıs SQL Servardan disccnnet olursa bu tablo bellekten silinir.
--- Diğer bütün özellikleri # İle oluşturulan tablo İle aynıdır.


-- Uniqueidentifier Veri TİPİ
-- inti varchar vs. gibi bir veri tipidir.
--- Aldığı değer, rakamlar ve harflerden oluşan çok büyük bir sayıdır.
-- Bundan dolayı bu kolona aynı değerin birden fazla gelmesi neredeyse imkansızdır.
--- O yüzden tekil bir veri oluşturmak için kullanılır.

USe OrnekVeriTabani
create table ornektable
(
Id int primary key identity(1,1),
FirstName nvarchar(50),
MailCode uniqueidentifier 

)

--NEWID() Fonksiyonu
insert into ornektable values('Oğuzhan',NEWID())

select * from ornektable




---- View Yapısı
--Kullanım
--Genellikle karmaşık sorguların tek bir sorgu üzerinden çalıştırılabilmesidir.
---- Bu amaçla raporlama işlemlerinde kullanılabilirler.
--- Aynı zamanda güvenlik ihtiyacı olduğu durumlarda herhangi bir sorgunun 2. - 3. şahıslardan gizlenmesi amacıyla da kullanılırlar.
--- Genel Özellikleri
--Herhangi bir sorgunun sonucunu tablo olarak ele alıp, ondan sorgu çekilebilmesini sağlarlar.
---- ***Önemli***insert, Update ve Delete yapabilirler. Bu işlemleri fiziksel tabloya yansıtırlar. 
---- View yapıları fiziksel olarak oluşturulan yapılardır.
---- View yapıları normal sorgulardan daha yavaş çalışırlar.
--Dikkat !
---- Database elemanlarını Create komutuyla oluşturuyorduk. View yapısıda bir database yapısı olduğu İçin Create komutu İle oluşturacağız.

Create View vw_Gotur
As
Select p.Adi+' '+p.SoyAdi [Adı Soyadı],k.KategoriAdi [Kategori Adı], COUNT(s.SatisID) [Toplam Satış] from Personeller p inner join Satislar s on p.PersonelID=s.PersonelID
							inner join [Satis Detaylari] sd on s.SatisID=sd.SatisID
							inner join Urunler u on sd.UrunID=u.UrunID
							inner join Kategoriler k on k.KategoriID=u.KategoriID
							group by p.Adi+' '+p.SoyAdi, k.KategoriAdi 

select * from vw_Gotur

select * from vw_Gotur where [Adı Soyadı] Like '%Robert%'

-- View oluşturulurken kolonlara verilen aliaslar View'den sorgu çekilirken kullanılır.
-- Bir yandan da view'ın kullandığı gerçek tabloların kolon isimleri, View içinde alias tanımlanarak gizlenilmiş olunur.
-- View içinde "order by- kullanılamaz.
--"Order By" view içinde değil, view çalışırken sorgu esnasında kullanılmalıdır.
Select * from vw_Gotur order by [Toplam Satış]
-- Yok eğer İllaki ben View İçinde "order by" kullanacağım diyorsanız View içinde "top" korutunu kullanmalısınız.
--- Bu durun çokta tavsiye edilen bir durum değildir.

-- View üzerinde insert. Delete ve Update yapılabilir. Bu işlemler fiziksel tabloya yansıtılmaktadırlar.

Create View OrnekViewPersoneller
As
Select Adi,SoyAdi,Unvan from Personeller

Insert Into OrnekViewPersoneller(Adi,SoyAdi,Unvan) values('Faruk','Aslan','Senior DEV')
Update OrnekViewPersoneller set SoyAdi='Karaslan' where SoyAdi='Aslan'
Delete OrnekViewPersoneller where SoyAdi='Karaslan'
Select * from Personeller

--- Wİth Encryptİon Komutu
--- Eğer yazdığımız view'in kaynak kodlarını, Object Explorer penceresinde "Views" kategorisine sağ tıklayarak Design Mdda açıp
--görüntülenmesini istemiyorsak "With Encryption" komutu İle Viewi oluşturmalıyız.
--- Dikkat !
--"With Encryption" işleminden sonra vİew'İ oluşturan kişide dahil kimse komutları göremez. Geri dönüş yoktur. Ancak view'i oluşturan şahsın komutların yedeğini bulundurması gerekmektedir. Ya da "With Encryption" olmaksızın view yapısını yeniden alterlamalıyız.
--- Dikkat !
--- Bir dikkat etmemiz gereken nokta da "With Encryption" ifadesini "as" keywordünden önce yazmalıyız.

create view OrnekViewPersoneller 
With Encryption
as
Select Adi,SoyAdi,Unvan from Personeller
--- Bu işlemi yaptıktan sonra Design Modu kapatılmıştır.


---- Wİth Schemabinding Komutu
--- Eğer view'in kullandığı esas fiziksel tabloların kolon isimleri bir şekilde değiştirilir, kolonları silinir ya da tablo yapısı bir şekilde değişikliğe uğrar ise vİew'İn çalışması artık mümkün olmayacaktır.
---- View'in kullandığı tablolar ve kolonları bu tarz işlemler yapılabilmesi ihtimaline karşı koruma altına alınabilir.
---- Bu koruma "With Schemabinding" komutu ile yapılabilir.
--"With Schemabinding" ile view Create ya da Alter edilirken, view'in kullandığı tablo, schema adıyla birlikte verilmelidir. örneğin, dbo(database owner) bir şema adıdır. Şemalar C#'takİ namespaceler gibi düşünülebilir.
----"With Schemabinding" konutuda "As" keywordünden önce yazılmalıdır.

Create Table OrnekTablo
(
 Id int primary key identity(1,1),
 FirstName nvarchar(50),
 Kolon int
)

Create View OrnekViewTablo
With Schemabinding
as
Select Id,FirstName,Kolon from dbo.OrnekTablo

Alter Table OrnekTablo
Alter Column Kolon nvarchar(50)


--- With Check Option Komutu
-- View'in içerisindeki sorguda bulunan şarta uygun kayıtların insert edilmesine müsade edilip, uymayan kayıtların müsade edilmemesini sağlayan bir konuttur.

--"With Encryption" ve "With Schemabinding" komutları "As" keywordünden önce belirtilirken "With Check Option" komutu where şartından sonra belirtilmelidir.

Create View OrnekViewTabo2
As
Select Id,FirstName,Kolon from OrnekTablo where FirstName like'A%'
With Check Option

Insert OrnekViewTabo2 values('Oğuzhan',1) --Eklenemez

Insert OrnekViewTabo2 values('Ahmet',1)--Eklendi









--- Functions - Scalar Function - inline Function

--T -SQL 'de iki tip fonksiyon vardır.
--Scalar Fonksiyonlar Geriye istediğimiz bir tipte değer gönderen fonksiyon.
--- inline Fonksiyonlar Geriye tablo gönderen fonksiyon.

--Bu her iki fonksiyonda fiziksel olarak veritabanında oluşturulmaktadır.
--Create komutu ile oluşturulmaktadır.
--- Üzerinde çalışılan database'in Programmability -> Functions kombinasyonundan oluşturulan fonksiyonlara erişebilmekteyiz.


--— 1. Scalar Function —
---- Fonksiyon Tanımlama
--- Scalar fonksiyonlara tanımlandıktan sonra Programmability Functions Scalar- valued Functions kombinasyonundan erişilebilir.
USE Northwind
Create Function Topla(@Sayi1 int, @Sayi2 int) Returns int 
As
	Begin
		return @Sayi1 + @Sayi2
	End
--Oluşturulan bu fonksiyonu düzeltmek isterseniz Programmability->Sclar-valued Functions klasöründen ismin üzerine gelip sağ tıklayınca Modify seçilerek düzeltme yapılabilir.

--- Fonksiyon Kullanımı
--- Fonksiyonu kullanırken şemasıyla beraber çağrılmalıdır.

select dbo.Topla(2,1)
print dbo.Topla(3,5)

--Örnek
--"Northwind” veri tabanında; herhangi bir ürünün %18 KDV dahil olmak üzere toplam maliyetini getiren fonksiyonu yazalım.

Create Function Maliyet(@BirimFiyati int, @StokMiktari int) Returns nvarchar(max)
As
	Begin
		declare @sonuc int=@BirimFiyati*@StokMiktari*1.18
		return @sonuc
	End
Select dbo.Maliyet(10,20)


--2. inline Function
--- Geriye bir değer değil, tablo gönderen fonksiyonlardır.
--Geriye tablo göndereceği için bu fonksiyonlar çalıştırılırken sanki bir tablodan sorgu çalıştırılır gibi çalıştırılırlar. Bu yönleriyle viewlara benzerler. View ile yapılan işlevler inline Functions • lapla yapılabilir.
--Genellikle viewle benzer işlevler için View kullanılmasını öneririm.

--- Fonksiyon Tanımlama
--- inline fonksiyonlara tanımlandıktan sonra Programmability -> Functions->Table-valued Functions kombinasyonundan erişilebilir.
--Dikkat !
--- inline Function oluşturulurken Begin End yapısı kullanılmaz.

Create Function fc_Gonder(@Ad nvarchar(20), @Soyad nvarchar(20)) Returns Table
As
	return Select Adi,Soyadi from Personeller where Adi=@Ad and SoyAdi=@Soyad

--Fonksiyon Kullanımı
--- Fonksiyonu şemasıyla birlikte çağırmak gerekmektedir.
select * from dbo.fc_Gonder('Oğuzhan','Dilek')


---- Fonksiyonlarda With Encryption Komutu
--Eğer ki yazmış olduğumuz fonksiyonların kodlarına 2. 3. şahısların erişimini engellemek istiyorsak ”With Encryption" komutunu kullanmalıyız.
--”With Encryption” işleminden sonra fonksiyonu oluşturan kişide dahil kimse komutları göremez. Geri dönüş yoktur. Ancak fonksiyonu oluşturan şahsın komutların yedeğini bulundurması gerekmektedir. Ya da "With Encryption” olmaksızın fonksiyonu yeniden alterlamalıyız.
--"With Encryption" "As" key wordünden önce kullanılmalıdır.

Create function OrnekFunc() Returns int
With Encryption
As
	Begin
	return 3
	End
Go
Select dbo.OrnekFunc()

Create function OrnekFunc2() Returns Table
With Encryption
As
	Return select * from Personeller

select * from dbo.OrnekFunc2()

--Encryption ettiğimiz fonksiyonları Alter ile Encryption'larını kaldıryoruz

Alter Function OrnekFunc() Returns int
as
	Begin
		return 3
	End

Alter function OrnekFunc2() Returns Table
As
	return Select * from Personeller


---- Otomatik Hesaplanabilir Kolonlar - Computed Column
--- Herhangi bir kolonda fonksiyon kullanılarak otomatik hesaplanabilir kolonlar
--(Computed Column) oluşturmak mümkündür.

Create function Topla(@Sayi1 int, @Sayi2 int) returns int
as
	Begin
		return @Sayi1+@Sayi2
	End
Select UrunAdi, dbo.Topla(BirimFiyati,HedefStokDuzeyi) HesapnamisKolon  from Urunler
--Örnek:
--Çıktı olarak "_____kategorisindeki ____ürününün toplam fiyatı __' dır. "şeklinde bir çıktı veren fonksiyonu yazalım.
Create function Rapor(@Kategori nvarchar(max),@UrunAdi nvarchar(max), @BirimFiyati int, @Stok int) Returns nvarchar(max)
As
	Begin
		declare @Cikti nvarchar(max) = @Kategori + ' kategorisindeki ' + @UrunAdi + ' ürünün toplam fiyatı ' + CAST(@BirimFiyati*@Stok as nvarchar(max)) + 'dır.'  
		return @Cikti
	End

Select dbo.Rapor(k.KategoriAdi,u.UrunAdi,u.BirimFiyati,u.HedefStokDuzeyi) From Urunler u join Kategoriler k on u.UrunID=k.KategoriID








----- Stored Procedures (Saklı Yordamlar)
------ Genel Özelliklerı

----Normal sorgulardan daha hızlı çalışırlar.
----Çünkü normal sorgular Execute edilirken "Execute Plan” işlemi yapılır. Bu işlem sırasında hangi tablodan veri çekilecek, hangi kolonlardan gelecek, bunlar nerede v.s gibi işlemler yapılır. Bir sorgu her çalıştırıldığında bu işlemler aynen tekrar tekrar yapılır. Fakat sorgu Stored Procedure olarak çalıştırılırsa bu işlem sadece bir kere yapılır ve o da ilk çalıştırma esnasındadır. Diğer çalıştırmalarda bu işlemler yapılmaz. Bundan dolayı hız ve performansta artış sağlanır.
----İçerisinde Select, insert, Update ve Delete işlemleri yapılabilir.
----iç içe kullanılabilir.
----İçlerinde fonksiyon olutşrulabilir.
----- Sorgularımızın dışarıdan alacağı değerler parametre olarak Stored Procedure' lere geçirilebildiğinden dolayı, sorgularımızın "SQL Injection” yemelerinide önlemiş oluruz. Bu yönleriyle de daha güvenlidirler.
----- Stored Procedure fiziksel bir veritabanı nesnesidir. Haliyle Create komutu ile oluşturulur.
----- Fiziksel olarak ilgili veritabanının "Programmability” "Stored Procedures" kombinasyonundan erişilebilirler.

--Prototip -
--- Create Proc ya da Procedure [İsim]
--(
--varsa parametreler
--)
--yazılacak sorgular, kodlar, şartlar,fonksiyonlar,komutlar



-- Stored Procedure Tanımlama

Create Proc sp_Ornek
(
	@Id int --Aksi söylenmediği taktirde bu parametrenin yapısı inputtur.
)
As
Select * from Personeller where PersonelID=@Id
--Dikkat !
--- Prosedürün parametrelerini tanımlarken parantez kullanmak zorunlu değildir ama okunabilirliği arttırmak için kullanmakta fayda vardır.

Create Procedure sp_Ornek2
	@Id int,
	@Parametre1 int,
	@Parametre2 nvarchar(max)
As
Select * from Personeller where PersonelID=@Id

---- Stored Procedure Kullanımı
--- Stored Procedure yapılarını "Exec" komutu eşliğinde çalıştırabilmekteyiz.

Exec sp_Ornek 3

Exec sp_Ornek2 4,4,'ASD'


-- Geriye Değer Döndüren Stored Procedure Yapısı

Create Proc urunGetir
(
	@Fiyat money
)
As
Select * from Urunler where BirimFiyati>@Fiyat
Return @@Rowcount

--Kullanımı
Exec urunGetir 40
--Bu şekilde geriye dönülen değeri elde etmeksizin kullanılabilir. Sıkıntı olmaz.

Declare @Sonuc int
Exec @Sonuc=urunGetir 40
print CAST(@Sonuc as nvarchar(max))+ ' adet ürün işlemden etkilenmişitr'